{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OC-Accel Overview OpenCAPI Acceleration Framework , abbreviated as OC-Accel , is a platform to enable programmers and computer engineers to quickly create FPGA-based accelerations. The acceleration action's software part and hardware part share the server host memory data through OpenCAPI interface. This framework was named SNAP framework for CAPI1.0 and CAPI2.0 and may be also referred as OC-SNAP. What is OpenCAPI OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium . What can I do with it OC-Accel helps you create an accelerator on a certain FPGA card with OpenCAPI interface. Refer to \"User Guide\" tab for a more detailed step-to-step guide. Generally, creating an accelerator includes the steps as below: Develop your accelerator Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also mentioned as \" action \" in the following description. Use some profiling tools to analyze the bottleneck or the heavy workload in your algorithm. Software/hardware partition : After isolating the functions to run on FPGA side, the parameters need to be nailed down. It can be described as a job data structure. Then design a job queue to process the jobs. Learning the examples (See in \"Examples\" tab) as an start. A few libosnap API functions help you manipulate the FPGA card and the software/hardware interface. Work on the hardware action: Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part which invokes this hardware action, OC-Accel supports running co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. The development is executed on an X86 Linux machine, with at least Xilinx Vivado installed. You can also use other supported simulators to get better simulation speed. A real FPGA card is NOT required for the plain development. Deploy it and run Deploy to Power9 server : Program the bitstream to a real FPGA card. Compile the software code and run! OC-Accel Framework Now let's have a glance at the diagram of OC-Accel framework. For more details about the directories, files and design hierarchy, see in reporsitory structure page. The framework hardware consists of an AXI-to-OpenCAPI bridge unit, which has memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through an AXI-MM interface. Optionally, it also provides access to the on-card DRAM via AXI. User can take this open-source framework to add other interfaces (for example, NVMe, Ethernet, HBM, etc) depending on the capabilities of the FPGA card . Software gets access to the action through the libosnap library, allowing applications to call a \"function\" instead of programming an accelerator. For more information, please refer to \"Deep Dive\" tab. Dependencies Required tools for development Development is usually done on a Linux (x86) computer . Xilinx Vivado : OC-Accel currently supports Xilinx FPGA devices exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 or 2018.3 tool suite are recommended. OpenCAPI TlxDLx package. Download them from \"link TODO\" Build process: Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the OC-Accel framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . Simulators: You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulators like Cadence irun or xcelium . For simulation, OC-Accel also relies on the xterm program. Supported FPGA cards OC-Accel framework needs a FPGA card with OpenCAPI interface, and a Slim-SAS cable to connect to a Power9 server. Today it supports: Alphadata 9V3 For FPGA vendors, it's easy to enable a new FPGA card with OpenCAPI interface to run OC-Accel, go to New board support page to learn how to. Supported Servers for deployment OpenCAPI interface needs the support on processor side. You can run OpenCAPI acceleration on Power9 servers with LaGrange or Monza processors installed. Today you can choose: LaGrange processor based systems: (link TODO) IPS FP5290 Wisrton Mihawk Monza processor based systems: IBM AC922 (an Acorn card is also required) Compliance with SNAP1.0/2.0 OpenCAPI is actually the third generation of CAPI technology . That's why its version starts from OpenCAPI3.0. The same acceleration framework for CAPI1.0 and CAPI2.0 is also an open-source git repository at https://github.com/open-power/snap . Correspondingly, we call that SNAP1.0/2.0. The supported cards can be found here . SNAP1.0 runs on Power8 servers, with PCIe Gen3x8 cards. SNAP2.0 runs on Power9 servers, with PCIe Gen3x16 or PCIe Gen4x8 cards. OC-Accel runs on Power9 servers, using OpenCAPI x8 interface. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-Accel directly without changing source-code. Check Migration Guide for more information. Read more (TODO) OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Overview"},{"location":"#oc-accel-overview","text":"OpenCAPI Acceleration Framework , abbreviated as OC-Accel , is a platform to enable programmers and computer engineers to quickly create FPGA-based accelerations. The acceleration action's software part and hardware part share the server host memory data through OpenCAPI interface. This framework was named SNAP framework for CAPI1.0 and CAPI2.0 and may be also referred as OC-SNAP.","title":"OC-Accel Overview"},{"location":"#what-is-opencapi","text":"OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium .","title":"What is OpenCAPI"},{"location":"#what-can-i-do-with-it","text":"OC-Accel helps you create an accelerator on a certain FPGA card with OpenCAPI interface. Refer to \"User Guide\" tab for a more detailed step-to-step guide. Generally, creating an accelerator includes the steps as below:","title":"What can I do with it"},{"location":"#develop-your-accelerator","text":"Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also mentioned as \" action \" in the following description. Use some profiling tools to analyze the bottleneck or the heavy workload in your algorithm. Software/hardware partition : After isolating the functions to run on FPGA side, the parameters need to be nailed down. It can be described as a job data structure. Then design a job queue to process the jobs. Learning the examples (See in \"Examples\" tab) as an start. A few libosnap API functions help you manipulate the FPGA card and the software/hardware interface. Work on the hardware action: Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part which invokes this hardware action, OC-Accel supports running co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. The development is executed on an X86 Linux machine, with at least Xilinx Vivado installed. You can also use other supported simulators to get better simulation speed. A real FPGA card is NOT required for the plain development.","title":"Develop your accelerator"},{"location":"#deploy-it-and-run","text":"Deploy to Power9 server : Program the bitstream to a real FPGA card. Compile the software code and run!","title":"Deploy it and run"},{"location":"#oc-accel-framework","text":"Now let's have a glance at the diagram of OC-Accel framework. For more details about the directories, files and design hierarchy, see in reporsitory structure page. The framework hardware consists of an AXI-to-OpenCAPI bridge unit, which has memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through an AXI-MM interface. Optionally, it also provides access to the on-card DRAM via AXI. User can take this open-source framework to add other interfaces (for example, NVMe, Ethernet, HBM, etc) depending on the capabilities of the FPGA card . Software gets access to the action through the libosnap library, allowing applications to call a \"function\" instead of programming an accelerator. For more information, please refer to \"Deep Dive\" tab.","title":"OC-Accel Framework"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#required-tools-for-development","text":"Development is usually done on a Linux (x86) computer . Xilinx Vivado : OC-Accel currently supports Xilinx FPGA devices exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 or 2018.3 tool suite are recommended. OpenCAPI TlxDLx package. Download them from \"link TODO\" Build process: Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the OC-Accel framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . Simulators: You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulators like Cadence irun or xcelium . For simulation, OC-Accel also relies on the xterm program.","title":"Required tools for development"},{"location":"#supported-fpga-cards","text":"OC-Accel framework needs a FPGA card with OpenCAPI interface, and a Slim-SAS cable to connect to a Power9 server. Today it supports: Alphadata 9V3 For FPGA vendors, it's easy to enable a new FPGA card with OpenCAPI interface to run OC-Accel, go to New board support page to learn how to.","title":"Supported FPGA cards"},{"location":"#supported-servers-for-deployment","text":"OpenCAPI interface needs the support on processor side. You can run OpenCAPI acceleration on Power9 servers with LaGrange or Monza processors installed. Today you can choose: LaGrange processor based systems: (link TODO) IPS FP5290 Wisrton Mihawk Monza processor based systems: IBM AC922 (an Acorn card is also required)","title":"Supported Servers for deployment"},{"location":"#compliance-with-snap1020","text":"OpenCAPI is actually the third generation of CAPI technology . That's why its version starts from OpenCAPI3.0. The same acceleration framework for CAPI1.0 and CAPI2.0 is also an open-source git repository at https://github.com/open-power/snap . Correspondingly, we call that SNAP1.0/2.0. The supported cards can be found here . SNAP1.0 runs on Power8 servers, with PCIe Gen3x8 cards. SNAP2.0 runs on Power9 servers, with PCIe Gen3x16 or PCIe Gen4x8 cards. OC-Accel runs on Power9 servers, using OpenCAPI x8 interface. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-Accel directly without changing source-code. Check Migration Guide for more information.","title":"Compliance with SNAP1.0/2.0"},{"location":"#read-more-todo","text":"OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Read more (TODO)"},{"location":"repository/","text":"Repository Structure The diagram below shows the entire diretory structure of OC-Accel GIT repository. It has a submodule oc-bip which contains the card specific packages and modules to support OpenCAPI protocol. The OpenCAPI transportation layer and data link layer modules TLx and DLx are two zip packages that can be downloaded from https://opencapi.org website (not included in this git repository.) Sub directories in oc-accel The framework has some facilitating components: Scripts : scripts for development environment. It displays a simple user interaction interface to select the card, the application to run (action), simulator, and other options. Defconfig : configuration files for Jenkins regression test (users don't neet them.) Web-doc : documentations (this webpage) Utilities : provides scripts to program FPGA bitstream to the card flash, and reset the card. It has the modules to bridge OpenCAPI protocol: Software : provides user library to operate OpenCAPI cards like open_device(), attach_action(), etc. It includes header files and some tools. Hardware : It has a TLx-to-AXI bridge Verilog design in hdl , the scripts to build a Vivado project and run the process in setup , the simluation scripts in sim , and the link to submodule oc-bip . Then it is the User Application actions directory. OC-Accel has already provided several examples in actions directory, including Verilog/VHDL examples and HLS (High Level Synthesis) examples. When a user wants to create a new Acceleration Application, he or she creates a new directory here. Under actions/<NAME> , use application also have software part sw , hardware part hw and test scripts test . Sub directories in oc-bip Any card vendor can add their card package support in oc-bip . The concept is similar to DSA (Device Support Archieve) or BSP (Board Support Package). Board_support_packages : Card vendor need to create a separate folder for a new device. It includes: Constraint files (xdc) to describe the Card pins, flash interface, configurations and so on. Tcl files to create necessary Vivado IPs. Enprypted Verilog files to use Xilinx high speed serdes IOs. Verilog files for parameters and FPGA top. config_subsystem : Shared common logic for OpenCAPI Config. scripts : to pack the entire oc-bip to a Vivado IP (oc_bsp_wrap.xci). sim : Top Verilog file for simulation. Tlx : Download the encrypted Zip package ibm.com_OpenCAPI_OC3_TLX_<VERSION>.zip and put here. Dlx : Download the encrypted Zip package ibm.com_OpenCAPI_OC3_DLX_<VERSION>.zip and put here. Filesets for Development and Deployment Files used in Simulation Step Files used in Implementation Step Files used in Deployment FPGA_TOP Hierarchy To generate a FPGA bitstream (binary image), the top design file is oc_fpga_top.v . oc_fpga_top is located in hardware/oc-bip/board_support_packeages/<CARD>/Verilog/framework_top oc_bsp_wrap includes TLx, Dlx, PHY, Flash subsystem, Config subsystem, and Card information (VPD). A script create_oc_bsp.tcl will assemble these components to a Vivado IP. In simulation, oc_bsp_wrap is NOT required because it is replaced by OpenCAPI Simulation Engine (OCSE). oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw","title":"About the repository"},{"location":"repository/#repository-structure","text":"The diagram below shows the entire diretory structure of OC-Accel GIT repository. It has a submodule oc-bip which contains the card specific packages and modules to support OpenCAPI protocol. The OpenCAPI transportation layer and data link layer modules TLx and DLx are two zip packages that can be downloaded from https://opencapi.org website (not included in this git repository.)","title":"Repository Structure"},{"location":"repository/#sub-directories-in-oc-accel","text":"The framework has some facilitating components: Scripts : scripts for development environment. It displays a simple user interaction interface to select the card, the application to run (action), simulator, and other options. Defconfig : configuration files for Jenkins regression test (users don't neet them.) Web-doc : documentations (this webpage) Utilities : provides scripts to program FPGA bitstream to the card flash, and reset the card. It has the modules to bridge OpenCAPI protocol: Software : provides user library to operate OpenCAPI cards like open_device(), attach_action(), etc. It includes header files and some tools. Hardware : It has a TLx-to-AXI bridge Verilog design in hdl , the scripts to build a Vivado project and run the process in setup , the simluation scripts in sim , and the link to submodule oc-bip . Then it is the User Application actions directory. OC-Accel has already provided several examples in actions directory, including Verilog/VHDL examples and HLS (High Level Synthesis) examples. When a user wants to create a new Acceleration Application, he or she creates a new directory here. Under actions/<NAME> , use application also have software part sw , hardware part hw and test scripts test .","title":"Sub directories in oc-accel"},{"location":"repository/#sub-directories-in-oc-bip","text":"Any card vendor can add their card package support in oc-bip . The concept is similar to DSA (Device Support Archieve) or BSP (Board Support Package). Board_support_packages : Card vendor need to create a separate folder for a new device. It includes: Constraint files (xdc) to describe the Card pins, flash interface, configurations and so on. Tcl files to create necessary Vivado IPs. Enprypted Verilog files to use Xilinx high speed serdes IOs. Verilog files for parameters and FPGA top. config_subsystem : Shared common logic for OpenCAPI Config. scripts : to pack the entire oc-bip to a Vivado IP (oc_bsp_wrap.xci). sim : Top Verilog file for simulation. Tlx : Download the encrypted Zip package ibm.com_OpenCAPI_OC3_TLX_<VERSION>.zip and put here. Dlx : Download the encrypted Zip package ibm.com_OpenCAPI_OC3_DLX_<VERSION>.zip and put here.","title":"Sub directories in oc-bip"},{"location":"repository/#filesets-for-development-and-deployment","text":"","title":"Filesets for Development and Deployment"},{"location":"repository/#files-used-in-simulation-step","text":"","title":"Files used in Simulation Step"},{"location":"repository/#files-used-in-implementation-step","text":"","title":"Files used in Implementation Step"},{"location":"repository/#files-used-in-deployment","text":"","title":"Files used in Deployment"},{"location":"repository/#fpga_top-hierarchy","text":"To generate a FPGA bitstream (binary image), the top design file is oc_fpga_top.v . oc_fpga_top is located in hardware/oc-bip/board_support_packeages/<CARD>/Verilog/framework_top oc_bsp_wrap includes TLx, Dlx, PHY, Flash subsystem, Config subsystem, and Card information (VPD). A script create_oc_bsp.tcl will assemble these components to a Vivado IP. In simulation, oc_bsp_wrap is NOT required because it is replaced by OpenCAPI Simulation Engine (OCSE). oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw","title":"FPGA_TOP Hierarchy"},{"location":"actions-doc/hdl-example/","text":"hdl_example This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-example/#hdl_example","text":"This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-helloworld/","text":"hdl_helloworld A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hdl-helloworld/#hdl_helloworld","text":"A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hls-helloworld/","text":"hls_helloworld High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-helloworld/#hls_helloworld","text":"High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-memcopy/","text":"hls_memcopy This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"actions-doc/hls-memcopy/#hls_memcopy","text":"This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"deep-dive/board-package/","text":"Get started This is my start. I want it.","title":"New Board Support"},{"location":"deep-dive/board-package/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"deep-dive/hardware-logic/","text":"SNAP Hardware: logic design Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide . SNAP setup Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names. SNAP configuration In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration. SNAP environment variables A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names. Image and model build Specifying the action Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step. CAPI board support and PSL for image build In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0). POWER8 CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP. POWER9 CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl . The make process If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system. FPGA bitstream image update Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch. Action wrapper The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly. HDL Action In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content. HLS Actions The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ). SDRAM Card Memory The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'. NVMe support For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details. Hardware debug with ILA cores In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images . Cloud support TBD... Simulation see ./sim/README.md for further instructions about Simulation","title":"Hardware Logic"},{"location":"deep-dive/hardware-logic/#snap-hardware-logic-design","text":"Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide .","title":"SNAP Hardware: logic design"},{"location":"deep-dive/hardware-logic/#snap-setup","text":"Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names.","title":"SNAP setup"},{"location":"deep-dive/hardware-logic/#snap-configuration","text":"In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration.","title":"SNAP configuration"},{"location":"deep-dive/hardware-logic/#snap-environment-variables","text":"A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names.","title":"SNAP environment variables"},{"location":"deep-dive/hardware-logic/#image-and-model-build","text":"","title":"Image and model build"},{"location":"deep-dive/hardware-logic/#specifying-the-action","text":"Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step.","title":"Specifying the action"},{"location":"deep-dive/hardware-logic/#capi-board-support-and-psl-for-image-build","text":"In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0).","title":"CAPI board support and PSL for image build"},{"location":"deep-dive/hardware-logic/#power8","text":"CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP.","title":"POWER8"},{"location":"deep-dive/hardware-logic/#power9","text":"CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl .","title":"POWER9"},{"location":"deep-dive/hardware-logic/#the-make-process","text":"If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system.","title":"The make process"},{"location":"deep-dive/hardware-logic/#fpga-bitstream-image-update","text":"Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch.","title":"FPGA bitstream image update"},{"location":"deep-dive/hardware-logic/#action-wrapper","text":"The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly.","title":"Action wrapper"},{"location":"deep-dive/hardware-logic/#hdl-action","text":"In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content.","title":"HDL Action"},{"location":"deep-dive/hardware-logic/#hls-actions","text":"The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ).","title":"HLS Actions"},{"location":"deep-dive/hardware-logic/#sdram-card-memory","text":"The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'.","title":"SDRAM Card Memory"},{"location":"deep-dive/hardware-logic/#nvme-support","text":"For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details.","title":"NVMe support"},{"location":"deep-dive/hardware-logic/#hardware-debug-with-ila-cores","text":"In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images .","title":"Hardware debug with ILA cores"},{"location":"deep-dive/hardware-logic/#cloud-support","text":"TBD...","title":"Cloud support"},{"location":"deep-dive/hardware-logic/#simulation","text":"see ./sim/README.md for further instructions about Simulation","title":"Simulation"},{"location":"deep-dive/registers/","text":"SNAP Registers Overview SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers. Register Definition Impl. Version Register (IVR) Name Offset Description Implementation Version Register 0x0000 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31..0 RO First eight digits of SHA ID for commit Build Date Register (BDR) Name Offset Description Build Date Register 0x0008 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute) SNAP Command Register (SCR) Name Offset Description SNAP Command Register 0x0010 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47..8 RO Reserved 7..0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP SNAP Status Register (SSR) Name Offset Description SNAP Status Register 0x0018 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID SNAP Lock Register (SLR) Name Offset Description SNAP Lock Register 0x0020 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..1 RO Reserved 0 RW Lock (Set on Read) SNAP Capability Register (SCR) Name Offset Description SNAP Capability Register 0x0030 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3 Freerunning Timer (FRT) Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock Job Timeout Register (JTR) Name Offset Description Job Timeout Register 0x0088 POR value: 0x80000000_0ABA9500 timeout enabled with 1s Bitwise definition Bits Attributes Description 63 RW Enable Job Timeout checking (1=enabled) 62..32 RO Reserved 31..0 RW Job Timeout value (this value decrements with the 250MHz PSL clock) Action Active Counter (AAC) Name Offset Description Action Active Counter 0x0090 Counter counting the number of clock cycles with an active action Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles with an active action. (TBD: when is an action considered active?). This counter increments with the 250MHz PSL clock. Job Execution Counter (JEC) Name Offset Description Job Execution Counter 0x0098 Counter counting the number of clock cycles while a job gets executed Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles while a job gets executed (TBD: when is a job considered as being executed?). This counter increments with the 250MHz PSL clock. Context ID Register (CIR) Name Offset Description Context ID Register 0x00A0 Context ID in this register Bitwise definition Bits Attributes Description 63 RW Set to '1' for master register 0 for slave 62..0 RO Reserved (no context ID for master bit 63 = 1) 62..9 RO Reserved (if bit 63 = 0) 8..0 RO My context id (if bit 63 = 0). (9 bits corresponding to context IDs in the range 0..511) Action Type Register i (ATRi) Name Offset Description Action Type Register i (0 <= i < 16) 0x0100 + i * 0x008 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented) Context Attach Status Vector (CASV) Name Offset Description Context Attach Status Vector m (0 <= m < 16) 0xC000 + i * 0x008 Status of each context Bitwise definition Bits Attributes Description 63..32 RO Reserved 31..0 RO Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31). Job Work Timer (JWT) Name Offset Description Job Work Timer 0x00001080 + (s+n) * 0x0010000 Timer for each job Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles during job execution for this context. (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset). This counter increments with the 250MHz PSL clock. Context Configuration Register (CCR) Name Offset Description Context Configuration Register 0x1000 Configuration of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RW Context configuration: 0x01: Direct Mode 0x02: Rise IRQ when Action goes to IDLE 0x04: Rise IRQ when Action is attached Context Status Register Name Offset Description Context Status Register 0x1008 Status of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RO Context status: 0x80: Short Action Type for this context is assigned 0x40: This context is attached to an action 0x01: Currently executing job 0x00: Context Active Job Command Register (JCR) Name Offset Description Job Command Register 0x1010 Send command to a job Bitwise definition Bits Attributes Description 63..16 RO Reserved 15..0 RO Job command: 0x0004: Reset Action, than Detach action from context 0x0002: Detach action from context 0x0001: Attach action to context","title":"Registers"},{"location":"deep-dive/registers/#snap-registers","text":"","title":"SNAP Registers"},{"location":"deep-dive/registers/#overview","text":"SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers.","title":"Overview"},{"location":"deep-dive/registers/#register-definition","text":"","title":"Register Definition"},{"location":"deep-dive/registers/#impl-version-register-ivr","text":"Name Offset Description Implementation Version Register 0x0000 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31..0 RO First eight digits of SHA ID for commit","title":"Impl. Version Register (IVR)"},{"location":"deep-dive/registers/#build-date-register-bdr","text":"Name Offset Description Build Date Register 0x0008 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute)","title":"Build Date Register (BDR)"},{"location":"deep-dive/registers/#snap-command-register-scr","text":"Name Offset Description SNAP Command Register 0x0010 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47..8 RO Reserved 7..0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP","title":"SNAP Command Register (SCR)"},{"location":"deep-dive/registers/#snap-status-register-ssr","text":"Name Offset Description SNAP Status Register 0x0018 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID","title":"SNAP Status Register (SSR)"},{"location":"deep-dive/registers/#snap-lock-register-slr","text":"Name Offset Description SNAP Lock Register 0x0020 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..1 RO Reserved 0 RW Lock (Set on Read)","title":"SNAP Lock Register (SLR)"},{"location":"deep-dive/registers/#snap-capability-register-scr","text":"Name Offset Description SNAP Capability Register 0x0030 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3","title":"SNAP Capability Register (SCR)"},{"location":"deep-dive/registers/#freerunning-timer-frt","text":"Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock","title":"Freerunning Timer (FRT)"},{"location":"deep-dive/registers/#job-timeout-register-jtr","text":"Name Offset Description Job Timeout Register 0x0088 POR value: 0x80000000_0ABA9500 timeout enabled with 1s Bitwise definition Bits Attributes Description 63 RW Enable Job Timeout checking (1=enabled) 62..32 RO Reserved 31..0 RW Job Timeout value (this value decrements with the 250MHz PSL clock)","title":"Job Timeout Register (JTR)"},{"location":"deep-dive/registers/#action-active-counter-aac","text":"Name Offset Description Action Active Counter 0x0090 Counter counting the number of clock cycles with an active action Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles with an active action. (TBD: when is an action considered active?). This counter increments with the 250MHz PSL clock.","title":"Action Active Counter (AAC)"},{"location":"deep-dive/registers/#job-execution-counter-jec","text":"Name Offset Description Job Execution Counter 0x0098 Counter counting the number of clock cycles while a job gets executed Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles while a job gets executed (TBD: when is a job considered as being executed?). This counter increments with the 250MHz PSL clock.","title":"Job Execution Counter (JEC)"},{"location":"deep-dive/registers/#context-id-register-cir","text":"Name Offset Description Context ID Register 0x00A0 Context ID in this register Bitwise definition Bits Attributes Description 63 RW Set to '1' for master register 0 for slave 62..0 RO Reserved (no context ID for master bit 63 = 1) 62..9 RO Reserved (if bit 63 = 0) 8..0 RO My context id (if bit 63 = 0). (9 bits corresponding to context IDs in the range 0..511)","title":"Context ID Register (CIR)"},{"location":"deep-dive/registers/#action-type-register-i-atri","text":"Name Offset Description Action Type Register i (0 <= i < 16) 0x0100 + i * 0x008 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented)","title":"Action Type Register i (ATRi)"},{"location":"deep-dive/registers/#context-attach-status-vector-casv","text":"Name Offset Description Context Attach Status Vector m (0 <= m < 16) 0xC000 + i * 0x008 Status of each context Bitwise definition Bits Attributes Description 63..32 RO Reserved 31..0 RO Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31).","title":"Context Attach Status Vector (CASV)"},{"location":"deep-dive/registers/#job-work-timer-jwt","text":"Name Offset Description Job Work Timer 0x00001080 + (s+n) * 0x0010000 Timer for each job Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles during job execution for this context. (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset). This counter increments with the 250MHz PSL clock.","title":"Job Work Timer (JWT)"},{"location":"deep-dive/registers/#context-configuration-register-ccr","text":"Name Offset Description Context Configuration Register 0x1000 Configuration of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RW Context configuration: 0x01: Direct Mode 0x02: Rise IRQ when Action goes to IDLE 0x04: Rise IRQ when Action is attached","title":"Context Configuration Register (CCR)"},{"location":"deep-dive/registers/#context-status-register","text":"Name Offset Description Context Status Register 0x1008 Status of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RO Context status: 0x80: Short Action Type for this context is assigned 0x40: This context is attached to an action 0x01: Currently executing job 0x00: Context Active","title":"Context Status Register"},{"location":"deep-dive/registers/#job-command-register-jcr","text":"Name Offset Description Job Command Register 0x1010 Send command to a job Bitwise definition Bits Attributes Description 63..16 RO Reserved 15..0 RO Job command: 0x0004: Reset Action, than Detach action from context 0x0002: Detach action from context 0x0001: Attach action to context","title":"Job Command Register (JCR)"},{"location":"deep-dive/software-api/","text":"SNAP Software Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks. Environment Variables To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here. Directory Structure . |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Software API"},{"location":"deep-dive/software-api/#snap-software","text":"Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks.","title":"SNAP Software"},{"location":"deep-dive/software-api/#environment-variables","text":"To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here.","title":"Environment Variables"},{"location":"deep-dive/software-api/#directory-structure","text":". |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Directory Structure"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . 4. Install Inkscape This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss. Website Structure First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them are created. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Use diagrams from PPT For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs .","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-inkscape","text":"This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss.","title":"4. Install Inkscape"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them are created. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#use-diagrams-from-ppt","text":"For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Use diagrams from PPT"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Deploy to Github Pages"},{"location":"user-guide/co-simulation/","text":"Get started This is my start. I want it.","title":"Co-Simulation"},{"location":"user-guide/co-simulation/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/command-reference/","text":"Get started This is my start. I want it.","title":"Command Reference"},{"location":"user-guide/command-reference/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/debug-issue/","text":"Get started This is my start.","title":"Debug an issue"},{"location":"user-guide/debug-issue/#get-started","text":"This is my start.","title":"Get started"},{"location":"user-guide/deploy/","text":"Get started This is my start. I want it.","title":"Deploy on Power Server"},{"location":"user-guide/deploy/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/make-image/","text":"Get started This is my start. I want it.","title":"FPGA Image build"},{"location":"user-guide/make-image/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/migrate-from-old/","text":"Migrate from SNAP1.0/2.0 The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"Migrate from SNAP1/2"},{"location":"user-guide/migrate-from-old/#migrate-from-snap1020","text":"The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"Migrate from SNAP1.0/2.0"},{"location":"user-guide/new-action/","text":"Get started This is my start. I want it.","title":"Create a new action"},{"location":"user-guide/new-action/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/optimize-hls/","text":"Get started This is my start. I want it.","title":"Optimize HLS action"},{"location":"user-guide/optimize-hls/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/prepare-env/","text":"This page will introduce the basic evironmental requests, tools, and general commands to run OC-Accel flow. Prepare Environment Basic Tools Firstly, you need to have an x86 machine for developement with Vivado tool and the license. source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> Note OC-Accel works on Vivado 2018.2 and 2018.3 Make sure you have gcc , make , sed , awk and xterm . python is optional, but it's better to install it. You may install other simulators to accelerate the speed of simulation. See in co-simulation for more information. Clone Github Repositories git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update cd .. git clone git@github.ibm.com:lancet/ocse.git It's better to have ocse stay in the same directory as oc-snap . That is the default path of $OCSE_ROOT . Or you need to assign the path of ocse in following steps. Option1: All-in-one python workflow script OC-Accel developed a \"one-step\" Python script to control the workflow. cd oc-snap ./snap_workflow.py This script will Check environmental variables make snap_config build model start simulation There are many options provided by snap_workflow.py . Check the help messages by ./snap_workflow.py --help It helps you to do all kinds of operations in one command line. Option2: Traditional \"make\" steps Just typing \"make\" doesn't work. Please give the explicit target. cd oc-snap make help Main targets for the SNAP Framework make process: ================================================= * snap_config Configure SNAP framework * model Build simulation model for simulator specified via target snap_config * sim Start a simulation * hw_project Create Vivado project with oc-bip * image Build a complete FPGA bitstream after make hw_project (will take more than one hour) * hardware One step to build FPGA bitstream (Combines targets 'model' and 'image' * software Build software libraries and tools for SNAP * apps Build the applications for all actions * clean Remove all files generated in make process * clean_config As target 'clean' plus reset of the configuration * help Print this message The hardware related targets 'model', 'image', 'hardware', 'hw_project' and 'sim' do only exist on an x86 platform If you have used SNAP for CAPI1.0 and CAPI2.0, you can continue to use these steps: For simulation make snap_config make model make sim Note make_sim can be replaced by call hardware/sim/run_sim script. For Image build make snap_config If it has already been executed, no need to run it again. make hw_project make image Note After make hw_project , you can go to hardware/viv_project and use vivado to open framework.xpr , then you can click run Synthesis , run Implemention and generate Bitstream buttons on Vivado GUI. Output files The log files during these processes are placed in hardware/logs . Simulation output files are placed in hardware/sim/[SIMULATOR]/latest . If you are using make image to generate bitstreams, the outputs are in hardware/build , including Images , Reports and Checkpoints . If you are using Vivado Gui mode to generate bitstream, the outputs are in hardware/viv_project/framework.runs , including synth_1 and impl_1 , etc. Let's go! Now, let's take an example hls_helloworld , and have a look at how it runs step by step. Please continue to read page Run helloworld .","title":"Prepare environment"},{"location":"user-guide/prepare-env/#prepare-environment","text":"","title":"Prepare Environment"},{"location":"user-guide/prepare-env/#basic-tools","text":"Firstly, you need to have an x86 machine for developement with Vivado tool and the license. source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> Note OC-Accel works on Vivado 2018.2 and 2018.3 Make sure you have gcc , make , sed , awk and xterm . python is optional, but it's better to install it. You may install other simulators to accelerate the speed of simulation. See in co-simulation for more information.","title":"Basic Tools"},{"location":"user-guide/prepare-env/#clone-github-repositories","text":"git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update cd .. git clone git@github.ibm.com:lancet/ocse.git It's better to have ocse stay in the same directory as oc-snap . That is the default path of $OCSE_ROOT . Or you need to assign the path of ocse in following steps.","title":"Clone Github Repositories"},{"location":"user-guide/prepare-env/#option1-all-in-one-python-workflow-script","text":"OC-Accel developed a \"one-step\" Python script to control the workflow. cd oc-snap ./snap_workflow.py This script will Check environmental variables make snap_config build model start simulation There are many options provided by snap_workflow.py . Check the help messages by ./snap_workflow.py --help It helps you to do all kinds of operations in one command line.","title":"Option1: All-in-one python workflow script"},{"location":"user-guide/prepare-env/#option2-traditional-make-steps","text":"Just typing \"make\" doesn't work. Please give the explicit target. cd oc-snap make help Main targets for the SNAP Framework make process: ================================================= * snap_config Configure SNAP framework * model Build simulation model for simulator specified via target snap_config * sim Start a simulation * hw_project Create Vivado project with oc-bip * image Build a complete FPGA bitstream after make hw_project (will take more than one hour) * hardware One step to build FPGA bitstream (Combines targets 'model' and 'image' * software Build software libraries and tools for SNAP * apps Build the applications for all actions * clean Remove all files generated in make process * clean_config As target 'clean' plus reset of the configuration * help Print this message The hardware related targets 'model', 'image', 'hardware', 'hw_project' and 'sim' do only exist on an x86 platform If you have used SNAP for CAPI1.0 and CAPI2.0, you can continue to use these steps:","title":"Option2: Traditional \"make\" steps"},{"location":"user-guide/prepare-env/#for-simulation","text":"make snap_config make model make sim Note make_sim can be replaced by call hardware/sim/run_sim script.","title":"For simulation"},{"location":"user-guide/prepare-env/#for-image-build","text":"make snap_config If it has already been executed, no need to run it again. make hw_project make image Note After make hw_project , you can go to hardware/viv_project and use vivado to open framework.xpr , then you can click run Synthesis , run Implemention and generate Bitstream buttons on Vivado GUI.","title":"For Image build"},{"location":"user-guide/prepare-env/#output-files","text":"The log files during these processes are placed in hardware/logs . Simulation output files are placed in hardware/sim/[SIMULATOR]/latest . If you are using make image to generate bitstreams, the outputs are in hardware/build , including Images , Reports and Checkpoints . If you are using Vivado Gui mode to generate bitstream, the outputs are in hardware/viv_project/framework.runs , including synth_1 and impl_1 , etc.","title":"Output files"},{"location":"user-guide/prepare-env/#lets-go","text":"Now, let's take an example hls_helloworld , and have a look at how it runs step by step. Please continue to read page Run helloworld .","title":"Let's go!"},{"location":"user-guide/run-helloworld/","text":"Get started This is my start. I want it.","title":"Run helloworld"},{"location":"user-guide/run-helloworld/#get-started","text":"This is my start. I want it.","title":"Get started"}]}