{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OC-Accel Overview OpenCAPI Acceleration Framework , abbreviated as OC-Accel , is a platform to enable programmers and computer engineers to quickly create FPGA-based accelerations. The acceleration action's software part and hardware part share the server host memory data through OpenCAPI interface. All of the codes and materials are on Github https://github.com/OpenCAPI/oc-accel ( TODO : This link is not ready yet). OC-Accel sometimes may also be referred as OC-SNAP because for CAPI1.0 and CAPI2.0, the framework with same purpose was named SNAP . What is OpenCAPI OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium . What can I do with it OC-Accel helps you create an accelerator on a certain FPGA card with OpenCAPI interface. Refer to \" User Guide \" tab for a more detailed step-to-step guide. Generally, creating an accelerator includes the steps as below: Develop your accelerator Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also mentioned as \" action \" in the following description. Use some profiling tools to analyze the bottleneck or the heavy workload in your algorithm. Software/hardware partition : After isolating the functions to run on FPGA side, the parameters need to be nailed down. It can be described as a job data structure. Learning the examples (See in \" Examples \" tab) as an start. A few libosnap API functions help you manipulate the FPGA card and the software/hardware interface. Work on the hardware action: Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part which invokes this hardware action, OC-Accel supports running co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. The development is executed on an X86 Linux machine, with at least Xilinx Vivado installed. You can also install other supported simulators to get better simulation speed. A real FPGA card is NOT required in the process of development. Deploy it and run Deploy to Power9 server : Program the bitstream to a real FPGA card. Compile the software code on Power9 and run! OC-Accel Framework Now let's have a glance at the diagram of OC-Accel framework. For more details about the directories, files and design hierarchy, see in repository structure page. The framework hardware consists of: TLx/DLx: Transaction layer and datalink layer of OpenCAPI device. cfg: Config subsystem of OpenCAPI snap_core: In Bridge mode, it provides the protocol translation for two directions. Module \"mmio\" converts TLx commands from Host Server to AXI4-Lite slave interface. Module \"bridge\" converts AXI4-MM commands from User logic \"Hardware Action\" to the host. Hardware action: also named \"action_wrapper\" is where developers implement their accelerator logic. People can take this open-source framework to add other interfaces (for example, NVMe, Ethernet, HBM, etc) depending on the capabilities of the FPGA card. The framework software consists of: libosnap: a few user-space functions to talk to upper applications. Developers can define them freely. libocxl: a few user-space functions talking to kernel module ocxl. ocxl: Linux kernel module to support OpenCAPI hardware. Already included with the OS distributions. For more information, please refer to \" Deep Dive \" tab on the menu bar. Dependencies Required tools for development Development is usually done on a Linux (x86) computer . Xilinx Vivado : OC-Accel currently supports Xilinx FPGA devices exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.3 or newer tool suites are recommended. Build process: Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the OC-Accel framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . pyhton is optional but suggested to install. 2.7.x is fine. Simulators: You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulators like Cadence irun or xcelium . For simulation, OC-Accel also relies on the xterm program. Supported FPGA cards OC-Accel framework needs a FPGA card with OpenCAPI interface, and a Slim-SAS cable to connect to a Power9 server. Today it supports: Alphadata 9V3 For FPGA vendors, it's easy to enable a new FPGA card with OpenCAPI interface to run OC-Accel, go to New board support page to learn how to. Supported Servers for deployment OpenCAPI interface needs the support on processor side. You can run OpenCAPI acceleration on Power9 servers with LaGrange or Monza processors installed. Today you can choose: LaGrange processor based systems: (link TODO ) IPS FP5290 Wisrton Mihawk Monza processor based systems: IBM AC922 (an Acorn card is also required.) How to report an issue Submit an \"Issue\" on the GitHub. How to search information There are two ways: Use the \"Search\" button on the menu bar (up right). Or search the opened webpage by Ctrl+F . Git clone this repository and use grep or any of your favorite tools to search \"web-doc\" folder in a terminal. All of the contents on this website are plain text so you can search them easily. For example: cd web-doc grep KEYWORD * -r Compliance with SNAP1.0/2.0 OpenCAPI is actually the third generation of CAPI technology . That's why its version starts from OpenCAPI3.0. The same acceleration framework for CAPI1.0 and CAPI2.0 is also an open-source git repository at https://github.com/open-power/snap . Correspondingly, we call that SNAP1.0/2.0. The supported cards can be found here . SNAP1.0 runs on Power8 servers, with PCIe Gen3x8 cards. SNAP2.0 runs on Power9 servers, with PCIe Gen3x16 or PCIe Gen4x8 cards. OC-Accel runs on Power9 servers, using OpenCAPI x8 interface. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-Accel directly without changing source-code. Check Migration Guide for more information. Read more (TODO) OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Overview"},{"location":"#oc-accel-overview","text":"OpenCAPI Acceleration Framework , abbreviated as OC-Accel , is a platform to enable programmers and computer engineers to quickly create FPGA-based accelerations. The acceleration action's software part and hardware part share the server host memory data through OpenCAPI interface. All of the codes and materials are on Github https://github.com/OpenCAPI/oc-accel ( TODO : This link is not ready yet). OC-Accel sometimes may also be referred as OC-SNAP because for CAPI1.0 and CAPI2.0, the framework with same purpose was named SNAP .","title":"OC-Accel Overview"},{"location":"#what-is-opencapi","text":"OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium .","title":"What is OpenCAPI"},{"location":"#what-can-i-do-with-it","text":"OC-Accel helps you create an accelerator on a certain FPGA card with OpenCAPI interface. Refer to \" User Guide \" tab for a more detailed step-to-step guide. Generally, creating an accelerator includes the steps as below:","title":"What can I do with it"},{"location":"#develop-your-accelerator","text":"Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also mentioned as \" action \" in the following description. Use some profiling tools to analyze the bottleneck or the heavy workload in your algorithm. Software/hardware partition : After isolating the functions to run on FPGA side, the parameters need to be nailed down. It can be described as a job data structure. Learning the examples (See in \" Examples \" tab) as an start. A few libosnap API functions help you manipulate the FPGA card and the software/hardware interface. Work on the hardware action: Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part which invokes this hardware action, OC-Accel supports running co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. The development is executed on an X86 Linux machine, with at least Xilinx Vivado installed. You can also install other supported simulators to get better simulation speed. A real FPGA card is NOT required in the process of development.","title":"Develop your accelerator"},{"location":"#deploy-it-and-run","text":"Deploy to Power9 server : Program the bitstream to a real FPGA card. Compile the software code on Power9 and run!","title":"Deploy it and run"},{"location":"#oc-accel-framework","text":"Now let's have a glance at the diagram of OC-Accel framework. For more details about the directories, files and design hierarchy, see in repository structure page. The framework hardware consists of: TLx/DLx: Transaction layer and datalink layer of OpenCAPI device. cfg: Config subsystem of OpenCAPI snap_core: In Bridge mode, it provides the protocol translation for two directions. Module \"mmio\" converts TLx commands from Host Server to AXI4-Lite slave interface. Module \"bridge\" converts AXI4-MM commands from User logic \"Hardware Action\" to the host. Hardware action: also named \"action_wrapper\" is where developers implement their accelerator logic. People can take this open-source framework to add other interfaces (for example, NVMe, Ethernet, HBM, etc) depending on the capabilities of the FPGA card. The framework software consists of: libosnap: a few user-space functions to talk to upper applications. Developers can define them freely. libocxl: a few user-space functions talking to kernel module ocxl. ocxl: Linux kernel module to support OpenCAPI hardware. Already included with the OS distributions. For more information, please refer to \" Deep Dive \" tab on the menu bar.","title":"OC-Accel Framework"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#required-tools-for-development","text":"Development is usually done on a Linux (x86) computer . Xilinx Vivado : OC-Accel currently supports Xilinx FPGA devices exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.3 or newer tool suites are recommended. Build process: Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the OC-Accel framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . pyhton is optional but suggested to install. 2.7.x is fine. Simulators: You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulators like Cadence irun or xcelium . For simulation, OC-Accel also relies on the xterm program.","title":"Required tools for development"},{"location":"#supported-fpga-cards","text":"OC-Accel framework needs a FPGA card with OpenCAPI interface, and a Slim-SAS cable to connect to a Power9 server. Today it supports: Alphadata 9V3 For FPGA vendors, it's easy to enable a new FPGA card with OpenCAPI interface to run OC-Accel, go to New board support page to learn how to.","title":"Supported FPGA cards"},{"location":"#supported-servers-for-deployment","text":"OpenCAPI interface needs the support on processor side. You can run OpenCAPI acceleration on Power9 servers with LaGrange or Monza processors installed. Today you can choose: LaGrange processor based systems: (link TODO ) IPS FP5290 Wisrton Mihawk Monza processor based systems: IBM AC922 (an Acorn card is also required.)","title":"Supported Servers for deployment"},{"location":"#how-to-report-an-issue","text":"Submit an \"Issue\" on the GitHub.","title":"How to report an issue"},{"location":"#how-to-search-information","text":"There are two ways: Use the \"Search\" button on the menu bar (up right). Or search the opened webpage by Ctrl+F . Git clone this repository and use grep or any of your favorite tools to search \"web-doc\" folder in a terminal. All of the contents on this website are plain text so you can search them easily. For example: cd web-doc grep KEYWORD * -r","title":"How to search information"},{"location":"#compliance-with-snap1020","text":"OpenCAPI is actually the third generation of CAPI technology . That's why its version starts from OpenCAPI3.0. The same acceleration framework for CAPI1.0 and CAPI2.0 is also an open-source git repository at https://github.com/open-power/snap . Correspondingly, we call that SNAP1.0/2.0. The supported cards can be found here . SNAP1.0 runs on Power8 servers, with PCIe Gen3x8 cards. SNAP2.0 runs on Power9 servers, with PCIe Gen3x16 or PCIe Gen4x8 cards. OC-Accel runs on Power9 servers, using OpenCAPI x8 interface. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-Accel directly without changing source-code. Check Migration Guide for more information.","title":"Compliance with SNAP1.0/2.0"},{"location":"#read-more-todo","text":"OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Read more (TODO)"},{"location":"repository/","text":"This page introduces the components and files in OC-Accel. For a step-by-step guidance, please start from User Guide Steps in a glance . Repository Structure The diagram below shows the entire diretory structure of OC-Accel GIT repository. It links to another repository OpenCAPI3.0_Client_RefDesign or oc-bip which contains the card specific packages and modules to support OpenCAPI protocol. Sub directories in oc-accel The framework has some facilitating components: scripts : scripts for development environment. It displays a simple user interaction interface to select the card, the application to run (action), simulator, and other options. defconfig : configuration files for Jenkins regression test (users don't need them.) web-doc : documentations (this webpage) It has the modules to bridge OpenCAPI protocol: Software : provides user library to operate OpenCAPI cards like open_device(), attach_action(), etc. It includes header files and some tools. Hardware : It has a TLx-to-AXI bridge Verilog design in hdl , the scripts to build a Vivado project and run the process in setup , the simulation scripts in sim , and the link to oc-bip . Then it is the User Application actions directory. OC-Accel has already provided several examples in actions directory, including Verilog/VHDL examples and HLS (High Level Synthesis) examples. When a user wants to create a new Acceleration Application, he or she creates a new directory here. Under actions/<NAME> , use application also have software part sw , hardware part hw and test scripts test . Sub directories in oc-bip Any card vendor can add their card package support in oc-bip . The concept is similar to DSA (Device Support Archive) or BSP (Board Support Package). Board_support_packages : Card vendor need to create a separate folder for a new device. It includes: Constraint files (xdc) to describe the Card pins, flash interface, configurations and so on. Tcl files to create necessary Vivado IPs. Enprypted Verilog files to use Xilinx high speed serdes IOs. Verilog files for parameters and FPGA top. config_subsystem : Shared common logic for OpenCAPI Config. scripts : to pack the entire oc-bip to a Vivado IP (oc_bsp_wrap.xci). sim : Top Verilog file for simulation. Tlx : OpenCAPI Device transaction layer reference design. Dlx : OpenCAPI Device data link layer reference design. For more information, please refer to New Board Support . Filesets and Hardware Hierarchy Files used in Simulation Step In accelerator development, software and hardware co-simulation is a very important step. The simulation doesn't contain module tlx and dlx, but replies on OCSE to emulate the behavior of host. For more information, please refer to Co-Simulation . OCSE (OpenCAPI Simulation Engine) is also required. (TODO: update link) Top hierarchy in Simulation Step top.sv is in oc-bip/sim directory. oc_cfg is OpenCAPI Configuration subsystem. oc_function is the DUT (Design under Test) in this step. oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw We use OCSE's DPI-C functions to drive and respond to the bus transactions. Files used in Implementation Step After co-simulation passed, it's time to do the Synthesis and Implementation in Vivado. For more information, please refer to User guide: build image . Top hierarchy in Implementation Step To generate a FPGA bitstream (binary image), the top design file is oc_fpga_top.v . oc_fpga_top is located in hardware/oc-bip/board_support_packeages/<CARD>/Verilog/framework_top oc_bsp_wrap includes TLx, Dlx, PHY, Flash subsystem and Card information (VPD). A script create_oc_bsp.tcl will assemble these components to a Vivado IP. oc_cfg is OpenCAPI Configuration subsystem. oc_function is what we have just simulated and proved that the functions can work correctly. oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw Files used in Deployment When FPGA bitstream is generated, use the tool oc-flash-script in oc-utils (TODO: update link) to download it from Power9 host server to the FPGA flash. After reboot, the bitstream takes effect and you can ask application to call FPGA acceleration, with the help of libosnap and libocxl . libocxl need to be installed. Please follow the README file on its homepage. Application software and libosnap need to be compiled on Power9 host server also. For more information, please refer to User-guide: deploy .","title":"About the repository"},{"location":"repository/#repository-structure","text":"The diagram below shows the entire diretory structure of OC-Accel GIT repository. It links to another repository OpenCAPI3.0_Client_RefDesign or oc-bip which contains the card specific packages and modules to support OpenCAPI protocol.","title":"Repository Structure"},{"location":"repository/#sub-directories-in-oc-accel","text":"The framework has some facilitating components: scripts : scripts for development environment. It displays a simple user interaction interface to select the card, the application to run (action), simulator, and other options. defconfig : configuration files for Jenkins regression test (users don't need them.) web-doc : documentations (this webpage) It has the modules to bridge OpenCAPI protocol: Software : provides user library to operate OpenCAPI cards like open_device(), attach_action(), etc. It includes header files and some tools. Hardware : It has a TLx-to-AXI bridge Verilog design in hdl , the scripts to build a Vivado project and run the process in setup , the simulation scripts in sim , and the link to oc-bip . Then it is the User Application actions directory. OC-Accel has already provided several examples in actions directory, including Verilog/VHDL examples and HLS (High Level Synthesis) examples. When a user wants to create a new Acceleration Application, he or she creates a new directory here. Under actions/<NAME> , use application also have software part sw , hardware part hw and test scripts test .","title":"Sub directories in oc-accel"},{"location":"repository/#sub-directories-in-oc-bip","text":"Any card vendor can add their card package support in oc-bip . The concept is similar to DSA (Device Support Archive) or BSP (Board Support Package). Board_support_packages : Card vendor need to create a separate folder for a new device. It includes: Constraint files (xdc) to describe the Card pins, flash interface, configurations and so on. Tcl files to create necessary Vivado IPs. Enprypted Verilog files to use Xilinx high speed serdes IOs. Verilog files for parameters and FPGA top. config_subsystem : Shared common logic for OpenCAPI Config. scripts : to pack the entire oc-bip to a Vivado IP (oc_bsp_wrap.xci). sim : Top Verilog file for simulation. Tlx : OpenCAPI Device transaction layer reference design. Dlx : OpenCAPI Device data link layer reference design. For more information, please refer to New Board Support .","title":"Sub directories in oc-bip"},{"location":"repository/#filesets-and-hardware-hierarchy","text":"","title":"Filesets and Hardware Hierarchy"},{"location":"repository/#files-used-in-simulation-step","text":"In accelerator development, software and hardware co-simulation is a very important step. The simulation doesn't contain module tlx and dlx, but replies on OCSE to emulate the behavior of host. For more information, please refer to Co-Simulation . OCSE (OpenCAPI Simulation Engine) is also required. (TODO: update link)","title":"Files used in Simulation Step"},{"location":"repository/#top-hierarchy-in-simulation-step","text":"top.sv is in oc-bip/sim directory. oc_cfg is OpenCAPI Configuration subsystem. oc_function is the DUT (Design under Test) in this step. oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw We use OCSE's DPI-C functions to drive and respond to the bus transactions.","title":"Top hierarchy in Simulation Step"},{"location":"repository/#files-used-in-implementation-step","text":"After co-simulation passed, it's time to do the Synthesis and Implementation in Vivado. For more information, please refer to User guide: build image .","title":"Files used in Implementation Step"},{"location":"repository/#top-hierarchy-in-implementation-step","text":"To generate a FPGA bitstream (binary image), the top design file is oc_fpga_top.v . oc_fpga_top is located in hardware/oc-bip/board_support_packeages/<CARD>/Verilog/framework_top oc_bsp_wrap includes TLx, Dlx, PHY, Flash subsystem and Card information (VPD). A script create_oc_bsp.tcl will assemble these components to a Vivado IP. oc_cfg is OpenCAPI Configuration subsystem. oc_function is what we have just simulated and proved that the functions can work correctly. oc_snap_core is in hardware/hdl User logic action_wrapper will be implemented in actions/<NAME>/hw","title":"Top hierarchy in Implementation Step"},{"location":"repository/#files-used-in-deployment","text":"When FPGA bitstream is generated, use the tool oc-flash-script in oc-utils (TODO: update link) to download it from Power9 host server to the FPGA flash. After reboot, the bitstream takes effect and you can ask application to call FPGA acceleration, with the help of libosnap and libocxl . libocxl need to be installed. Please follow the README file on its homepage. Application software and libosnap need to be compiled on Power9 host server also. For more information, please refer to User-guide: deploy .","title":"Files used in Deployment"},{"location":"actions-doc/hdl_example/","text":"hdl_example This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl_example/#hdl_example","text":"This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl_single_engine/","text":"hdl_helloworld A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_single_engine"},{"location":"actions-doc/hdl_single_engine/#hdl_helloworld","text":"A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hls_helloworld/","text":"hls_helloworld High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls_helloworld/#hls_helloworld","text":"High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls_memcopy_1024/","text":"hls_memcopy This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy_1024"},{"location":"actions-doc/hls_memcopy_1024/#hls_memcopy","text":"This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"deep-dive/board-package/","text":"Get started This is my start. I want it.","title":"New Board Support"},{"location":"deep-dive/board-package/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"deep-dive/hardware-logic/","text":"SNAP Hardware: logic design Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide . SNAP setup Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names. SNAP configuration In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration. SNAP environment variables A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names. Image and model build Specifying the action Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step. CAPI board support and PSL for image build In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0). POWER8 CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP. POWER9 CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl . The make process If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system. FPGA bitstream image update Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch. Action wrapper The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly. HDL Action In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content. HLS Actions The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ). SDRAM Card Memory The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'. NVMe support For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details. Hardware debug with ILA cores In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images . Cloud support TBD... Simulation see ./sim/README.md for further instructions about Simulation","title":"Hardware Logic"},{"location":"deep-dive/hardware-logic/#snap-hardware-logic-design","text":"Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide .","title":"SNAP Hardware: logic design"},{"location":"deep-dive/hardware-logic/#snap-setup","text":"Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names.","title":"SNAP setup"},{"location":"deep-dive/hardware-logic/#snap-configuration","text":"In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration.","title":"SNAP configuration"},{"location":"deep-dive/hardware-logic/#snap-environment-variables","text":"A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names.","title":"SNAP environment variables"},{"location":"deep-dive/hardware-logic/#image-and-model-build","text":"","title":"Image and model build"},{"location":"deep-dive/hardware-logic/#specifying-the-action","text":"Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step.","title":"Specifying the action"},{"location":"deep-dive/hardware-logic/#capi-board-support-and-psl-for-image-build","text":"In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0).","title":"CAPI board support and PSL for image build"},{"location":"deep-dive/hardware-logic/#power8","text":"CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP.","title":"POWER8"},{"location":"deep-dive/hardware-logic/#power9","text":"CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl .","title":"POWER9"},{"location":"deep-dive/hardware-logic/#the-make-process","text":"If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system.","title":"The make process"},{"location":"deep-dive/hardware-logic/#fpga-bitstream-image-update","text":"Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch.","title":"FPGA bitstream image update"},{"location":"deep-dive/hardware-logic/#action-wrapper","text":"The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly.","title":"Action wrapper"},{"location":"deep-dive/hardware-logic/#hdl-action","text":"In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content.","title":"HDL Action"},{"location":"deep-dive/hardware-logic/#hls-actions","text":"The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ).","title":"HLS Actions"},{"location":"deep-dive/hardware-logic/#sdram-card-memory","text":"The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'.","title":"SDRAM Card Memory"},{"location":"deep-dive/hardware-logic/#nvme-support","text":"For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details.","title":"NVMe support"},{"location":"deep-dive/hardware-logic/#hardware-debug-with-ila-cores","text":"In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images .","title":"Hardware debug with ILA cores"},{"location":"deep-dive/hardware-logic/#cloud-support","text":"TBD...","title":"Cloud support"},{"location":"deep-dive/hardware-logic/#simulation","text":"see ./sim/README.md for further instructions about Simulation","title":"Simulation"},{"location":"deep-dive/registers/","text":"SNAP Registers Overview SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers. Address Map Only lower 32bits are used for MMIO addresses. There are two regions: SNAP registers and Action registers. * SNAP registers are 64b registers, use snap_mmio_read64/write64() to access them, and the address should be aligned to 8. SNAP registers are in global MMIO space. It has three categories: * SNAP Basic Registers: addr[20:8] = 0x0000; * SNAP Debug Registers: addr[20:8] = 0x0001; * SNAP FIR Registers: addr[20:8] = 0x0002; Action registers are 32b registers, use snap_action_read32/write32() to access them, and the address should be aligned to 4. Action registers are in per PASID MMIO space. They are completely user defined. User can freely use 2MB space, that means, using addr[20:0]. Register Definition SNAP Basic Registers Impl. Version Register (IVR) Name Offset Description Implementation Version Register 0x00 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31..0 RO First eight digits of SHA ID for commit Build Date Register (BDR) Name Offset Description Build Date Register 0x08 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute) SNAP Command Register (SCR) Name Offset Description SNAP Command Register 0x10 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47..8 RO Reserved 7..0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP SNAP Status Register (SSR) Name Offset Description SNAP Status Register 0x18 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID SNAP Capability Register (CAP) Name Offset Description SNAP Capability Register 0x20 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x31 : AD9V3 0x32 : AD9H7 0x33 : N250SoC 0x34 : Innova2 0x35 : AD9H3 Action Type Register (ATR) Name Offset Description Action Type Register 0x28 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented) Freerunning Timer (FRT) Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock SNAP Debug Registers 0x0 Debug Clear Register (DBG_CLR) Name Offset Description Debug Clear Register 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock","title":"Registers"},{"location":"deep-dive/registers/#snap-registers","text":"","title":"SNAP Registers"},{"location":"deep-dive/registers/#overview","text":"SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers.","title":"Overview"},{"location":"deep-dive/registers/#address-map","text":"Only lower 32bits are used for MMIO addresses. There are two regions: SNAP registers and Action registers. * SNAP registers are 64b registers, use snap_mmio_read64/write64() to access them, and the address should be aligned to 8. SNAP registers are in global MMIO space. It has three categories: * SNAP Basic Registers: addr[20:8] = 0x0000; * SNAP Debug Registers: addr[20:8] = 0x0001; * SNAP FIR Registers: addr[20:8] = 0x0002; Action registers are 32b registers, use snap_action_read32/write32() to access them, and the address should be aligned to 4. Action registers are in per PASID MMIO space. They are completely user defined. User can freely use 2MB space, that means, using addr[20:0].","title":"Address Map"},{"location":"deep-dive/registers/#register-definition","text":"","title":"Register Definition"},{"location":"deep-dive/registers/#snap-basic-registers","text":"","title":"SNAP Basic Registers"},{"location":"deep-dive/registers/#impl-version-register-ivr","text":"Name Offset Description Implementation Version Register 0x00 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31..0 RO First eight digits of SHA ID for commit","title":"Impl. Version Register (IVR)"},{"location":"deep-dive/registers/#build-date-register-bdr","text":"Name Offset Description Build Date Register 0x08 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute)","title":"Build Date Register (BDR)"},{"location":"deep-dive/registers/#snap-command-register-scr","text":"Name Offset Description SNAP Command Register 0x10 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47..8 RO Reserved 7..0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP","title":"SNAP Command Register (SCR)"},{"location":"deep-dive/registers/#snap-status-register-ssr","text":"Name Offset Description SNAP Status Register 0x18 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID","title":"SNAP Status Register (SSR)"},{"location":"deep-dive/registers/#snap-capability-register-cap","text":"Name Offset Description SNAP Capability Register 0x20 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x31 : AD9V3 0x32 : AD9H7 0x33 : N250SoC 0x34 : Innova2 0x35 : AD9H3","title":"SNAP Capability Register (CAP)"},{"location":"deep-dive/registers/#action-type-register-atr","text":"Name Offset Description Action Type Register 0x28 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented)","title":"Action Type Register (ATR)"},{"location":"deep-dive/registers/#freerunning-timer-frt","text":"Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock","title":"Freerunning Timer (FRT)"},{"location":"deep-dive/registers/#snap-debug-registers-0x0","text":"","title":"SNAP Debug Registers 0x0"},{"location":"deep-dive/registers/#debug-clear-register-dbg_clr","text":"Name Offset Description Debug Clear Register 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock","title":"Debug Clear Register (DBG_CLR)"},{"location":"deep-dive/software-api/","text":"SNAP Software Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks. Environment Variables To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here. Directory Structure . |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Software API"},{"location":"deep-dive/software-api/#snap-software","text":"Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks.","title":"SNAP Software"},{"location":"deep-dive/software-api/#environment-variables","text":"To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here.","title":"Environment Variables"},{"location":"deep-dive/software-api/#directory-structure","text":". |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Directory Structure"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker. 4. Install other optional tools pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics. Website Structure First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Tools to draw diagrams You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. typora . It supports all of the platforms (Windows/MacOS/Linux). Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . vscode . It's also a good editor and has abundant functions and extensions. You can install extensions of Markdown, Preview and Spell checker.","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-other-optional-tools","text":"pdf2svg: This tool can convert a pdf lossless picture to svg format. For Mac OS, it can be easily installed by Homebrew , simply by brew install pdf2svg . Alternative choice is Inkscape which is a free drawing tool and can help you draw and convert vector graphics.","title":"4. Install other optional tools"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. Use relative links in the document. Note If you are using Typora, please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#tools-to-draw-diagrams","text":"You can take any drawing tools to create diagrams. You can save them as PNG format, but the better way is to save to SVG format. For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Tools to draw diagrams"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Deploy to Github Pages"},{"location":"user-guide/0-steps/","text":"Steps in a glance Under \"User-guide\" menu, the pages/steps are organized in this way: If you are new to OC-Accel, please go through (1), (2), and (8). With running helloworld, you will get an idea about the workflow and basic operations quickly. After that, it's time to create your own accelerator (\"action\"). Then go through (1), (3), (4/5), (6), (7), (8). If you already have an action developed in SNAP1/2 and want to move to OC-Accel, please read the notes in (9). Tips and Known issues are being updated in (10).","title":"(0) Steps in a glance"},{"location":"user-guide/0-steps/#steps-in-a-glance","text":"Under \"User-guide\" menu, the pages/steps are organized in this way: If you are new to OC-Accel, please go through (1), (2), and (8). With running helloworld, you will get an idea about the workflow and basic operations quickly. After that, it's time to create your own accelerator (\"action\"). Then go through (1), (3), (4/5), (6), (7), (8). If you already have an action developed in SNAP1/2 and want to move to OC-Accel, please read the notes in (9). Tips and Known issues are being updated in (10).","title":"Steps in a glance"},{"location":"user-guide/1-prepare-env/","text":"This page will introduce the basic environmental requests, tools, and general commands to run OC-Accel flow. Prepare Environment Basic Tools Firstly, you need to have an x86 machine for development with Vivado Tool and the license. export XILINX_VIVADO=<...path...>/Xilinx/Vivado/<VERSION> export XILINXD_LICENSE_FILE=<pointer to Xilinx license> export PATH=$PATH:${XILINX_VIVADO}/bin Note OC-Accel works on Vivado 2018.2, 2018.3 and 2019.1 For AD9H3 and AD9H7 cards with HBM, Vivado version is at least 2018.3 There is a file setup_tools.ksh in the root directory for reference. But for the beginning, only Vivado is required. Make sure you have gcc , make , sed , awk , xterm and python installed. setup_tools.ksh You may install other simulators to accelerate the speed of simulation. For example, Cadence xcelium . See in co-simulation for more information. Clone Github Repositories TODO: Link to update git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update cd .. git clone git@github.ibm.com:lancet/ocse.git It's better to have ocse stay in the same directory parallel to oc-snap . That is the default path of $OCSE_ROOT . Or you need to assign $OCSE_ROOT explicitly in snap_env.sh . Basic terms Option1: All-in-one python script OC-Accel developed a \"all-in-one\" Python script to control the workflow. It's convenient to do batch work, or enable your regression verification or continuous integration. cd oc-snap ./ocaccel_workflow.py This script will Check environmental variables make snap_config build model start simulation There are many options provided by ocaccel_workflow.py . Check the help messages by ./ocaccel_workflow.py --help It helps you to do all kinds of operations in one command line. Option2: Traditional \"make\" steps If you have used SNAP for CAPI1.0 and CAPI2.0, you can continue to use these \"traditional\" make steps. Just typing \"make\" doesn't work. An explicit target is needed. You can find them in Makefile file. cd oc-snap make help Main targets for the SNAP Framework make process: ================================================= * snap_config Configure SNAP framework * model Build simulation model for simulator specified via target snap_config * sim Start a simulation * sim_tmux Start a simulation in tmux (no xterm window popped up) * hw_project Create Vivado project with oc-bip * image Build a complete FPGA bitstream after hw_project (takes more than one hour) * hardware One step to build FPGA bitstream (Combines targets 'model' and 'image') * software Build software libraries and tools for SNAP * apps Build the applications for all actions * clean Remove all files generated in make process * clean_config As target 'clean' plus reset of the configuration * help Print this message The hardware related targets 'model', 'image', 'hardware', 'hw_project' and 'sim' do only exist on an x86 platform For simulation make snap_config make model make sim Note After make model , you can continue to run make image to generate bitstreams. In fact, make model also creates a Vivado project framework.xpr in hardware/viv_project . Then it exports the simulation files and compiles them to a simulation model. For Image build make snap_config If it has already been executed, no need to run it again. make hw_project make image Note Use Vivado GUI : After make hw_project , you can open project framework.xpr in hardware/viv_project , and do following \"run Synthesis\" , \"run Implementation\" and \"generate Bitstream\" in Vivado GUI. Output files The log files during these steps are placed in hardware/logs . Simulation output files are placed in hardware/sim/<SIMULATOR>/latest . If you are using make image to generate bitstreams, the outputs are in hardware/build , including Images , Reports and Checkpoints . If you are using Vivado Gui mode to generate bitstream, the outputs are in hardware/viv_project/framework.runs , including synth_1 and impl_1 , etc. Let's go! Now, let's take an example hls_helloworld , and have a look at how it runs step by step. Please continue to read page Run helloworld .","title":"(1) Prepare environment"},{"location":"user-guide/1-prepare-env/#prepare-environment","text":"","title":"Prepare Environment"},{"location":"user-guide/1-prepare-env/#basic-tools","text":"Firstly, you need to have an x86 machine for development with Vivado Tool and the license. export XILINX_VIVADO=<...path...>/Xilinx/Vivado/<VERSION> export XILINXD_LICENSE_FILE=<pointer to Xilinx license> export PATH=$PATH:${XILINX_VIVADO}/bin Note OC-Accel works on Vivado 2018.2, 2018.3 and 2019.1 For AD9H3 and AD9H7 cards with HBM, Vivado version is at least 2018.3 There is a file setup_tools.ksh in the root directory for reference. But for the beginning, only Vivado is required. Make sure you have gcc , make , sed , awk , xterm and python installed. setup_tools.ksh You may install other simulators to accelerate the speed of simulation. For example, Cadence xcelium . See in co-simulation for more information.","title":"Basic Tools"},{"location":"user-guide/1-prepare-env/#clone-github-repositories","text":"TODO: Link to update git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update cd .. git clone git@github.ibm.com:lancet/ocse.git It's better to have ocse stay in the same directory parallel to oc-snap . That is the default path of $OCSE_ROOT . Or you need to assign $OCSE_ROOT explicitly in snap_env.sh .","title":"Clone Github Repositories"},{"location":"user-guide/1-prepare-env/#basic-terms","text":"","title":"Basic terms"},{"location":"user-guide/1-prepare-env/#option1-all-in-one-python-script","text":"OC-Accel developed a \"all-in-one\" Python script to control the workflow. It's convenient to do batch work, or enable your regression verification or continuous integration. cd oc-snap ./ocaccel_workflow.py This script will Check environmental variables make snap_config build model start simulation There are many options provided by ocaccel_workflow.py . Check the help messages by ./ocaccel_workflow.py --help It helps you to do all kinds of operations in one command line.","title":"Option1: All-in-one python script"},{"location":"user-guide/1-prepare-env/#option2-traditional-make-steps","text":"If you have used SNAP for CAPI1.0 and CAPI2.0, you can continue to use these \"traditional\" make steps. Just typing \"make\" doesn't work. An explicit target is needed. You can find them in Makefile file. cd oc-snap make help Main targets for the SNAP Framework make process: ================================================= * snap_config Configure SNAP framework * model Build simulation model for simulator specified via target snap_config * sim Start a simulation * sim_tmux Start a simulation in tmux (no xterm window popped up) * hw_project Create Vivado project with oc-bip * image Build a complete FPGA bitstream after hw_project (takes more than one hour) * hardware One step to build FPGA bitstream (Combines targets 'model' and 'image') * software Build software libraries and tools for SNAP * apps Build the applications for all actions * clean Remove all files generated in make process * clean_config As target 'clean' plus reset of the configuration * help Print this message The hardware related targets 'model', 'image', 'hardware', 'hw_project' and 'sim' do only exist on an x86 platform","title":"Option2: Traditional \"make\" steps"},{"location":"user-guide/1-prepare-env/#for-simulation","text":"make snap_config make model make sim Note After make model , you can continue to run make image to generate bitstreams. In fact, make model also creates a Vivado project framework.xpr in hardware/viv_project . Then it exports the simulation files and compiles them to a simulation model.","title":"For simulation"},{"location":"user-guide/1-prepare-env/#for-image-build","text":"make snap_config If it has already been executed, no need to run it again. make hw_project make image Note Use Vivado GUI : After make hw_project , you can open project framework.xpr in hardware/viv_project , and do following \"run Synthesis\" , \"run Implementation\" and \"generate Bitstream\" in Vivado GUI.","title":"For Image build"},{"location":"user-guide/1-prepare-env/#output-files","text":"The log files during these steps are placed in hardware/logs . Simulation output files are placed in hardware/sim/<SIMULATOR>/latest . If you are using make image to generate bitstreams, the outputs are in hardware/build , including Images , Reports and Checkpoints . If you are using Vivado Gui mode to generate bitstream, the outputs are in hardware/viv_project/framework.runs , including synth_1 and impl_1 , etc.","title":"Output files"},{"location":"user-guide/1-prepare-env/#lets-go","text":"Now, let's take an example hls_helloworld , and have a look at how it runs step by step. Please continue to read page Run helloworld .","title":"Let's go!"},{"location":"user-guide/10-tips/","text":"Get started This is my start. I want it.","title":"(10) Tips"},{"location":"user-guide/10-tips/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/2-run-helloworld/","text":"Run hls_helloworld snap_config cd oc-snap ./ocaccel_workflow.py Then a KConfig window will popped up. If it doesn't, check Required tools and search 'kconfig' on the homepage. Select HLS HelloWorld in \"Action Type\". There are some other choices listed in the menu. Please input OCSE_ROOT path. Select xsim (the default simulator). To select a TRUE/FALSE feature, press \"Y\" or \"N\". After everything done, move cursor to \"Exit\". Note This Kconfig menu is editable. If you want to add new features or enrich your own menu, please edit scripts/Kconfig file. Then it starts to execute many steps to build a simulation model. It needs several minutes. While waiting for it, open another terminal tab and try to get familiar with some environmental variables. Open snap_env.sh and check the very basic ones: export ACTION_ROOT=<path_of_oc-snap>/actions/hls_helloworld export TIMING_LABLIMIT=\"-200\" export OCSE_ROOT=<path_to_ocse>/ocse Simulation ocaccel-workflow.py continues running and prints: SNAP Configured You've got configuration like: ACTION_ROOT /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/oc-snap/actions/hls_helloworld FPGACARD AD9V3 FPGACHIP xcvu3p-ffvc1517-2-e SIMULATOR xsim CAPI_VER opencapi30 OCSE_ROOT ../ocse --------> Environment Check vivado installed as /afs/bb/proj/fpga/xilinx/Vivado/2018.3/bin/vivado gcc installed as /bin/gcc xterm installed as /bin/xterm OCSE path /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/ocse is valid SNAP ROOT /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/oc-snap is valid Environment check PASSED --------> Make the simulation model Runnig ... check ./snap_workflow.make_model.log for details of full progress [CREATE_SNAP_IPs.....] start - [=========== ] 37% Then a Xterm window will popped up. (If it doesn't, check if you have installed it by typing xterm in your terminal.) This Xterm window is where you run your application (software part). You can run anything as many times as you want in the xterm window, just like running in the terminal of a real server with FPGA card plugged. Warning If you want to save the content running in this xterm window, please use script before running any commands. When you exit xterm window, everything is saved to a file -- \"typescript\" is its default name. $ script Script started, file is typescript ...... Run Anything ..... $ exit exit Script done, file is typescript Now let's run application snap_helloworld . It is located in $ACTION_ROOT/sw , where $ACTION_ROOT is <path_of_oc-snap>/actions/hls_helloworld . In the above window, it prints the help messages because it requires two arguments: an input text file and an output text file. We have prepared a script in $ACTION_ROOT/tests/hw_test.sh and you can run it directly. This example is asking FPGA to read the input file from host memory, converting the letters to capital case, and write them back to host memory and save in the output file. Now you have finished the software/hardware co-simulation. Type 'exit' in xterm window. All the output logs, waveforms are in hardware/sim/<simulator>/latest . hdclf154: luyong /afs/bb/u/luyong/p9/nd2/oc_dev/oc-snap/hardware/sim/xsim/latest $ ls debug.log ocse_server.dat snap_helloworld.log tin webtalk.jou xsim.dir xsrun.tcl ocse.log shim_host.dat tCAP top.wdb webtalk.log xsim.jou ocse.parms sim.log terminal.log tout xsaet.tcl xsim.log And you can use following command to open the waveform. xsim top.wdb -gui & On the project scope (hierarchy) panel, the user logic is action_w . Make FPGA bitstream In above steps, you actually have finished steps of: make snap_config make model make sim (These targets are introduced in Traditional \"make\" steps ) Now you can generate FPGA bitstream by ./ocaccel_workflow.py --no_configure --no_make_model --no_run_sim --make_image It takes about 2 hours or more. For some big design or bad-timing design, it takes even longer. Check the progress: ./snap_workflow.make_image.log Or hardware/logs/snap_build.log for more detailed logs. For example, ./snap_workflow.make_image.log may tell you: [BUILD IMAGE.........] start 16:58:57 Sat Sep 14 2019 A complete FPGA bitstream build got kicked off. This might take more than an hour depending on the machine used The process may be terminated by pressing <CTRL>-C at any time. After termination it can be restarted later. open framework project 16:59:06 Sat Sep 14 2019 start synthesis with directive: Default 16:59:25 Sat Sep 14 2019 start opt_design with directive: Explore 17:18:58 Sat Sep 14 2019 reload opt_design DCP 17:27:19 Sat Sep 14 2019 start place_design with directive: Explore 17:28:23 Sat Sep 14 2019 start phys_opt_design with directive: Explore 17:42:58 Sat Sep 14 2019 start route_design with directive: Explore 18:04:55 Sat Sep 14 2019 start opt_routed_design with directive: Explore 18:39:01 Sat Sep 14 2019 generating reports 18:57:28 Sat Sep 14 2019 Timing (WNS) -11 ps WARNING: TIMING FAILED, but may be OK for lab use generating bitstreams type: user image 18:58:28 Sat Sep 14 2019 So you can have an estimation of the progress. After it's completed, you can find the FPGA bitstream/image files in hardware/build/Images . The file names have the information of build date/time, action name, card type and timing slack (-11ps here). $ cd hardware/build/Images $ ls oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11.bit oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_primary.bin oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_primary.prm oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_secondary.bin oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_secondary.prm Note A small negative timing slack less than 200ps (set in variable $TIMING_LABLIMIT), is usually acceptable for Lab test, but for product, it's suggested to work out a timing cleaned FPGA image. See Build image for more information. Then go to Deploy on Power Server to see how to download the bitstream and run. Summary Now you understand how to run an existing example. You can use the same method to run other examples in actions directory.","title":"(2) Run helloworld"},{"location":"user-guide/2-run-helloworld/#run-hls_helloworld","text":"","title":"Run hls_helloworld"},{"location":"user-guide/2-run-helloworld/#snap_config","text":"cd oc-snap ./ocaccel_workflow.py Then a KConfig window will popped up. If it doesn't, check Required tools and search 'kconfig' on the homepage. Select HLS HelloWorld in \"Action Type\". There are some other choices listed in the menu. Please input OCSE_ROOT path. Select xsim (the default simulator). To select a TRUE/FALSE feature, press \"Y\" or \"N\". After everything done, move cursor to \"Exit\". Note This Kconfig menu is editable. If you want to add new features or enrich your own menu, please edit scripts/Kconfig file. Then it starts to execute many steps to build a simulation model. It needs several minutes. While waiting for it, open another terminal tab and try to get familiar with some environmental variables. Open snap_env.sh and check the very basic ones: export ACTION_ROOT=<path_of_oc-snap>/actions/hls_helloworld export TIMING_LABLIMIT=\"-200\" export OCSE_ROOT=<path_to_ocse>/ocse","title":"snap_config"},{"location":"user-guide/2-run-helloworld/#simulation","text":"ocaccel-workflow.py continues running and prints: SNAP Configured You've got configuration like: ACTION_ROOT /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/oc-snap/actions/hls_helloworld FPGACARD AD9V3 FPGACHIP xcvu3p-ffvc1517-2-e SIMULATOR xsim CAPI_VER opencapi30 OCSE_ROOT ../ocse --------> Environment Check vivado installed as /afs/bb/proj/fpga/xilinx/Vivado/2018.3/bin/vivado gcc installed as /bin/gcc xterm installed as /bin/xterm OCSE path /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/ocse is valid SNAP ROOT /afs/vlsilab.boeblingen.ibm.com/data/vlsi/eclipz/c14/usr/luyong/p9nd2/oc_dev/oc-snap is valid Environment check PASSED --------> Make the simulation model Runnig ... check ./snap_workflow.make_model.log for details of full progress [CREATE_SNAP_IPs.....] start - [=========== ] 37% Then a Xterm window will popped up. (If it doesn't, check if you have installed it by typing xterm in your terminal.) This Xterm window is where you run your application (software part). You can run anything as many times as you want in the xterm window, just like running in the terminal of a real server with FPGA card plugged. Warning If you want to save the content running in this xterm window, please use script before running any commands. When you exit xterm window, everything is saved to a file -- \"typescript\" is its default name. $ script Script started, file is typescript ...... Run Anything ..... $ exit exit Script done, file is typescript Now let's run application snap_helloworld . It is located in $ACTION_ROOT/sw , where $ACTION_ROOT is <path_of_oc-snap>/actions/hls_helloworld . In the above window, it prints the help messages because it requires two arguments: an input text file and an output text file. We have prepared a script in $ACTION_ROOT/tests/hw_test.sh and you can run it directly. This example is asking FPGA to read the input file from host memory, converting the letters to capital case, and write them back to host memory and save in the output file. Now you have finished the software/hardware co-simulation. Type 'exit' in xterm window. All the output logs, waveforms are in hardware/sim/<simulator>/latest . hdclf154: luyong /afs/bb/u/luyong/p9/nd2/oc_dev/oc-snap/hardware/sim/xsim/latest $ ls debug.log ocse_server.dat snap_helloworld.log tin webtalk.jou xsim.dir xsrun.tcl ocse.log shim_host.dat tCAP top.wdb webtalk.log xsim.jou ocse.parms sim.log terminal.log tout xsaet.tcl xsim.log And you can use following command to open the waveform. xsim top.wdb -gui & On the project scope (hierarchy) panel, the user logic is action_w .","title":"Simulation"},{"location":"user-guide/2-run-helloworld/#make-fpga-bitstream","text":"In above steps, you actually have finished steps of: make snap_config make model make sim (These targets are introduced in Traditional \"make\" steps ) Now you can generate FPGA bitstream by ./ocaccel_workflow.py --no_configure --no_make_model --no_run_sim --make_image It takes about 2 hours or more. For some big design or bad-timing design, it takes even longer. Check the progress: ./snap_workflow.make_image.log Or hardware/logs/snap_build.log for more detailed logs. For example, ./snap_workflow.make_image.log may tell you: [BUILD IMAGE.........] start 16:58:57 Sat Sep 14 2019 A complete FPGA bitstream build got kicked off. This might take more than an hour depending on the machine used The process may be terminated by pressing <CTRL>-C at any time. After termination it can be restarted later. open framework project 16:59:06 Sat Sep 14 2019 start synthesis with directive: Default 16:59:25 Sat Sep 14 2019 start opt_design with directive: Explore 17:18:58 Sat Sep 14 2019 reload opt_design DCP 17:27:19 Sat Sep 14 2019 start place_design with directive: Explore 17:28:23 Sat Sep 14 2019 start phys_opt_design with directive: Explore 17:42:58 Sat Sep 14 2019 start route_design with directive: Explore 18:04:55 Sat Sep 14 2019 start opt_routed_design with directive: Explore 18:39:01 Sat Sep 14 2019 generating reports 18:57:28 Sat Sep 14 2019 Timing (WNS) -11 ps WARNING: TIMING FAILED, but may be OK for lab use generating bitstreams type: user image 18:58:28 Sat Sep 14 2019 So you can have an estimation of the progress. After it's completed, you can find the FPGA bitstream/image files in hardware/build/Images . The file names have the information of build date/time, action name, card type and timing slack (-11ps here). $ cd hardware/build/Images $ ls oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11.bit oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_primary.bin oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_primary.prm oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_secondary.bin oc_2019_0914_1657_25G_hls_helloworld_noSDRAM_AD9V3_-11_secondary.prm Note A small negative timing slack less than 200ps (set in variable $TIMING_LABLIMIT), is usually acceptable for Lab test, but for product, it's suggested to work out a timing cleaned FPGA image. See Build image for more information. Then go to Deploy on Power Server to see how to download the bitstream and run.","title":"Make FPGA bitstream"},{"location":"user-guide/2-run-helloworld/#summary","text":"Now you understand how to run an existing example. You can use the same method to run other examples in actions directory.","title":"Summary"},{"location":"user-guide/3-new-action/","text":"A new git fork The first step before creating a new action is to create a git \"fork\". Now play on the forked git repository: git clone https://github.com/<MY_NAME>/oc-accel git submodule init git submodule update Delete the unnecessary branches, only keep \"master\", and create your own branches. When you want to sync with the original repository, do following steps: git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git Check status: git remote -v # origin https://github.com/MY_NAME/MY_FORK.git (fetch) # origin https://github.com/MY_NAME/MY_FORK.git (push) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Do the sync: git fetch upstream git merge upstream/master When you have some fixes and added some new features, create a pull request from your fork to the original repository. It will be reviewed and then the contribution will be merged. Note OC-Accel encourages people to create their own actions and the links will be recommended on README.md . But to keep the repository relatively small and neat, it will not copy every user action design into its original actions folder. Submit an issue or pull request to start the discussion. A new action We have several examples as references. Current action example list is: Name Type Description hdl_example VHDL 512b hdl_example inherited from SNAP1/2. Optional FPGA DDR. hdl_single_engine Verilog 1024b example to send AXI read/write commands. Used to measure bandwidth and latency. No FPGA DDR. hls_helloworld C/C++(HLS) 512b example to read data from host, convert to CAPITAL case and write back. No FPGA DDR. hls_memcopy_1024 C/C++(HLS) 1024b example to do memcopy. Enabled FPGA DDR. According to the action category, copy the folder of a proper example from actions and name it. Give it a name and type Step1: make snap_config Select HLS Action - manually set ... or HDL Action - manually set ... in the blue kconfig window. Step2: Edit snap_env.sh , point $ACTION_ROOT to the new action. export ACTION_ROOT=<...path...>/oc-snap/actions/my_new_action export TIMING_LABLIMIT=\"-200\" export OCSE_ROOT=<...path...>/ocse Step3: Edit software/tools/snap_actions.h , add a row of the new action, with the company/person name, action type ID, and a short description. static const struct actions_tab snap_actions[] = { { \"IBM\", 0x10140000, \"hdl_example in VHDL (512b)\" }, { \"IBM\", 0x10140002, \"hdl_single_engine in Verilog (1024b)\" }, { \"IBM\", 0x10140004, \"UVM test for unit verification (no OCSE and software)\" }, { \"IBM\", 0x10141001, \"HLS Sponge (512b)\" }, { \"IBM\", 0x10141008, \"HLS Hello World (512b)\" }, { \"IBM\", 0x1014100B, \"HLS Memcopy 1024 (1024b)\" }, }; Step4: The Action Type (for example, 0x10140000) should match with following places: actions/<my_new_action>/hw/ actions/<my_new_action>/sw/ Do a grep search and replace them. Understand the workflow Modify the example code (sw, hw and tests) to cook a new action. Understanding the workflow can help quickly identifying what's wrong. These steps are organized in Makefile hardware/Makefile software/Makefile Actions --> $ACTION_ROOT/hw/Makefile $ACTION_ROOT/sw/Makefile When adding a new action, before calling the \"All-in-one\" ocaccel_workflow.py, make sure the make process under $ACTION_ROOT works. cd $ACTION_ROOT/sw make cd $ACTION_ROOT/hw make Above figure shows the steps to make a simulation model. The Action related steps are marked in light orange color. There are also two important tricks: PREPROCESS : it will deal with the files with \"_source\" suffix. That means, \"FILE_source\" will be \"pre-processed\" and converted to \"FILE\". \"FILE\" is a generated one and should not be modified manually, and should not be committed to github either. Build Date/Time, Git Version and Card info will be hardcoded into snap_core logic by \" patch_version.sh \" Start simulation After clean up compiling errors in action sw and action hw, kick off a co-simulation by ./ocaccel_workflow.py","title":"(3) Create a new action"},{"location":"user-guide/3-new-action/#a-new-git-fork","text":"The first step before creating a new action is to create a git \"fork\". Now play on the forked git repository: git clone https://github.com/<MY_NAME>/oc-accel git submodule init git submodule update Delete the unnecessary branches, only keep \"master\", and create your own branches. When you want to sync with the original repository, do following steps: git remote add upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git Check status: git remote -v # origin https://github.com/MY_NAME/MY_FORK.git (fetch) # origin https://github.com/MY_NAME/MY_FORK.git (push) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (fetch) # upstream https://github.com/ORIGINAL_OWNER/ORIGINAL_REPOSITORY.git (push) Do the sync: git fetch upstream git merge upstream/master When you have some fixes and added some new features, create a pull request from your fork to the original repository. It will be reviewed and then the contribution will be merged. Note OC-Accel encourages people to create their own actions and the links will be recommended on README.md . But to keep the repository relatively small and neat, it will not copy every user action design into its original actions folder. Submit an issue or pull request to start the discussion.","title":"A new git fork"},{"location":"user-guide/3-new-action/#a-new-action","text":"We have several examples as references. Current action example list is: Name Type Description hdl_example VHDL 512b hdl_example inherited from SNAP1/2. Optional FPGA DDR. hdl_single_engine Verilog 1024b example to send AXI read/write commands. Used to measure bandwidth and latency. No FPGA DDR. hls_helloworld C/C++(HLS) 512b example to read data from host, convert to CAPITAL case and write back. No FPGA DDR. hls_memcopy_1024 C/C++(HLS) 1024b example to do memcopy. Enabled FPGA DDR. According to the action category, copy the folder of a proper example from actions and name it.","title":"A new action"},{"location":"user-guide/3-new-action/#give-it-a-name-and-type","text":"Step1: make snap_config Select HLS Action - manually set ... or HDL Action - manually set ... in the blue kconfig window. Step2: Edit snap_env.sh , point $ACTION_ROOT to the new action. export ACTION_ROOT=<...path...>/oc-snap/actions/my_new_action export TIMING_LABLIMIT=\"-200\" export OCSE_ROOT=<...path...>/ocse Step3: Edit software/tools/snap_actions.h , add a row of the new action, with the company/person name, action type ID, and a short description. static const struct actions_tab snap_actions[] = { { \"IBM\", 0x10140000, \"hdl_example in VHDL (512b)\" }, { \"IBM\", 0x10140002, \"hdl_single_engine in Verilog (1024b)\" }, { \"IBM\", 0x10140004, \"UVM test for unit verification (no OCSE and software)\" }, { \"IBM\", 0x10141001, \"HLS Sponge (512b)\" }, { \"IBM\", 0x10141008, \"HLS Hello World (512b)\" }, { \"IBM\", 0x1014100B, \"HLS Memcopy 1024 (1024b)\" }, }; Step4: The Action Type (for example, 0x10140000) should match with following places: actions/<my_new_action>/hw/ actions/<my_new_action>/sw/ Do a grep search and replace them.","title":"Give it a name and type"},{"location":"user-guide/3-new-action/#understand-the-workflow","text":"Modify the example code (sw, hw and tests) to cook a new action. Understanding the workflow can help quickly identifying what's wrong. These steps are organized in Makefile hardware/Makefile software/Makefile Actions --> $ACTION_ROOT/hw/Makefile $ACTION_ROOT/sw/Makefile When adding a new action, before calling the \"All-in-one\" ocaccel_workflow.py, make sure the make process under $ACTION_ROOT works. cd $ACTION_ROOT/sw make cd $ACTION_ROOT/hw make Above figure shows the steps to make a simulation model. The Action related steps are marked in light orange color. There are also two important tricks: PREPROCESS : it will deal with the files with \"_source\" suffix. That means, \"FILE_source\" will be \"pre-processed\" and converted to \"FILE\". \"FILE\" is a generated one and should not be modified manually, and should not be committed to github either. Build Date/Time, Git Version and Card info will be hardcoded into snap_core logic by \" patch_version.sh \"","title":"Understand the workflow"},{"location":"user-guide/3-new-action/#start-simulation","text":"After clean up compiling errors in action sw and action hw, kick off a co-simulation by ./ocaccel_workflow.py","title":"Start simulation"},{"location":"user-guide/4-hdl-design/","text":"Get started This is my start. I want it. Note The simulation runs thousands of times slower than the real hardware. In hls_helloworld example, these is only one test script hw_test.sh , but usually it's suggested to have at least two scripts like sim_test.sh and hw_test.sh . Run some small sized tests in simulation and run big/performance tests on real FPGA hardware.","title":"(4) Verilog/VHDL design"},{"location":"user-guide/4-hdl-design/#get-started","text":"This is my start. I want it. Note The simulation runs thousands of times slower than the real hardware. In hls_helloworld example, these is only one test script hw_test.sh , but usually it's suggested to have at least two scripts like sim_test.sh and hw_test.sh . Run some small sized tests in simulation and run big/performance tests on real FPGA hardware.","title":"Get started"},{"location":"user-guide/5-hls-design/","text":"Make FPGA Image (bitstream) Commands ./snap_workflow.py -s nosim -m OR (Old style) make snap_config make hw_project make image","title":"(5) HLS C++ design"},{"location":"user-guide/5-hls-design/#make-fpga-image-bitstream","text":"","title":"Make FPGA Image (bitstream)"},{"location":"user-guide/5-hls-design/#commands","text":"./snap_workflow.py -s nosim -m OR (Old style) make snap_config make hw_project make image","title":"Commands"},{"location":"user-guide/6-co-simulation/","text":"How to optimize a HLS action in OC-Accel environment The Guide describes how to measure and optimize the code of a function in SNAP environment. In a first step, you have ported your code to a FPGA. In a second step, you need to see how to optimize it. The final performance depends on the way you will write your code. Xilinx HLS guide ug902 is an important document for your to reference. Overview Let\u2019s use the very simple example hls_helloworld to learn how we can measure the time spent by the function, also called \u201chardware action\u201d, and how to optimize it. This example is so basic that you will not get much from it, but you will hopefully understand the concept. Notice that we use HLS (High Level Synthesis) tool in this example, because it provides a fast way to generate your own hardware implementation from a C/C+ code. Amongst others, the Xilinx Vivado HLS tool was selected since it is one that better enables those users who have less hardware knowledge. You can easily use the other HLS tools provided by other providers (Cadence, Mentor, ...) if the tool can generate HDL (Verilog, VHDL, ...) code. The helloworld example Before starting to dive into details, let us quickly explain what the example we are using is doing. The SNAP hls_helloworld sample application consists of a software part running on the host as well as a SNAP action which is executed with on the FPGA. The code running on the host-system opens a file, places the data into an input memory buffer, opens a context and triggers the action on the card to perform the data processing. Once the hardware action receives the order to start the job, it will transfer the data from the input memory buffer into the FPGA, does the requested processing, e.g. converting characters to upper case , and transfer the results back into the provided output memory on the host. The host application waits for the hardware action to complete, e.g. by using an interrupt or polling a special register. Once the hardware action signals completion, the action has processed the data and already written it into the provided output memory buffer. From there it is written into a new file. It can now be further processed. In the following sections it is explained how the data processing is done inside the FPGA and which steps can be used to analyze the performance as well as methods to improve it. Key data in HLS Open Vivado HLS The optimization of the code is essentially done on the hardware action. Go into hls_helloworld/hw directory, compile the hardware action and open vivado_hls tool. The compilation is necessary since this will set all parameters needed for the tool. cd $SNAP_ROOT/actions/hls_helloworld/hw make vivado_hls & Select Open Project Select hw directory, hlsUpperCasexxxx directory and then Select OK Understanding parameters preset by OC-Accel scripts Several parameters have been set by SNAP scripts when compiling the hardware action. Let\u2019s see where they are so that you can better understand why they are set to these values. In the menu, you have 2 important settings: one for the project and one for the solution. A project is related to the source code you are working on, while the solution is related to the FPGA you are working with. Go to Project > Project Settings , in Simulation tab , you will find the paths to all the header files used by your C/C++ hardware action code. You will notice that the last parameter of the CFLAGS line is -DNO_SYNTH . This allows the user to add at the end of the hardware action code an area delimited by \u201c#ifdef NO_SYNTH / #endif\u201d which contains a unit test for the hardware action. This area will not be \u201csynthesized\u201d meaning that the code in this area will not be implemented into the FPGA. In Synthesis tab , you will find the same line but without the -DNO_SYNTH . You will notice that at the top of this window, you can select a Top function . Push the Browse button and you will discover all the different functions contained in your hardware action. By default, the hls_action is selected since it is the top one. This feature gives you the ability to work with just part of your design instead of taking the whole function at once. This can be very useful when porting a function step by step. Now let\u2019s have a look at the other part of the settings. Go to Solution > Solution Settings . In the General tab , you can see a setting done on the config_interface . This is to declare that all address busses used in SNAP are declared to be 64 bits wide (default is 32 bits). In the Synthesis tab, you can select the clock period (250MHz = 4ns) and the FPGA exact type used by the card you are working with (XCKU060).","title":"(6) Co-Simulation"},{"location":"user-guide/6-co-simulation/#how-to-optimize-a-hls-action-in-oc-accel-environment","text":"The Guide describes how to measure and optimize the code of a function in SNAP environment. In a first step, you have ported your code to a FPGA. In a second step, you need to see how to optimize it. The final performance depends on the way you will write your code. Xilinx HLS guide ug902 is an important document for your to reference.","title":"How to optimize a HLS action in OC-Accel environment"},{"location":"user-guide/6-co-simulation/#overview","text":"Let\u2019s use the very simple example hls_helloworld to learn how we can measure the time spent by the function, also called \u201chardware action\u201d, and how to optimize it. This example is so basic that you will not get much from it, but you will hopefully understand the concept. Notice that we use HLS (High Level Synthesis) tool in this example, because it provides a fast way to generate your own hardware implementation from a C/C+ code. Amongst others, the Xilinx Vivado HLS tool was selected since it is one that better enables those users who have less hardware knowledge. You can easily use the other HLS tools provided by other providers (Cadence, Mentor, ...) if the tool can generate HDL (Verilog, VHDL, ...) code.","title":"Overview"},{"location":"user-guide/6-co-simulation/#the-helloworld-example","text":"Before starting to dive into details, let us quickly explain what the example we are using is doing. The SNAP hls_helloworld sample application consists of a software part running on the host as well as a SNAP action which is executed with on the FPGA. The code running on the host-system opens a file, places the data into an input memory buffer, opens a context and triggers the action on the card to perform the data processing. Once the hardware action receives the order to start the job, it will transfer the data from the input memory buffer into the FPGA, does the requested processing, e.g. converting characters to upper case , and transfer the results back into the provided output memory on the host. The host application waits for the hardware action to complete, e.g. by using an interrupt or polling a special register. Once the hardware action signals completion, the action has processed the data and already written it into the provided output memory buffer. From there it is written into a new file. It can now be further processed. In the following sections it is explained how the data processing is done inside the FPGA and which steps can be used to analyze the performance as well as methods to improve it.","title":"The helloworld example"},{"location":"user-guide/6-co-simulation/#key-data-in-hls","text":"","title":"Key data in HLS"},{"location":"user-guide/6-co-simulation/#open-vivado-hls","text":"The optimization of the code is essentially done on the hardware action. Go into hls_helloworld/hw directory, compile the hardware action and open vivado_hls tool. The compilation is necessary since this will set all parameters needed for the tool. cd $SNAP_ROOT/actions/hls_helloworld/hw make vivado_hls & Select Open Project Select hw directory, hlsUpperCasexxxx directory and then Select OK","title":"Open Vivado HLS"},{"location":"user-guide/6-co-simulation/#understanding-parameters-preset-by-oc-accel-scripts","text":"Several parameters have been set by SNAP scripts when compiling the hardware action. Let\u2019s see where they are so that you can better understand why they are set to these values. In the menu, you have 2 important settings: one for the project and one for the solution. A project is related to the source code you are working on, while the solution is related to the FPGA you are working with. Go to Project > Project Settings , in Simulation tab , you will find the paths to all the header files used by your C/C++ hardware action code. You will notice that the last parameter of the CFLAGS line is -DNO_SYNTH . This allows the user to add at the end of the hardware action code an area delimited by \u201c#ifdef NO_SYNTH / #endif\u201d which contains a unit test for the hardware action. This area will not be \u201csynthesized\u201d meaning that the code in this area will not be implemented into the FPGA. In Synthesis tab , you will find the same line but without the -DNO_SYNTH . You will notice that at the top of this window, you can select a Top function . Push the Browse button and you will discover all the different functions contained in your hardware action. By default, the hls_action is selected since it is the top one. This feature gives you the ability to work with just part of your design instead of taking the whole function at once. This can be very useful when porting a function step by step. Now let\u2019s have a look at the other part of the settings. Go to Solution > Solution Settings . In the General tab , you can see a setting done on the config_interface . This is to declare that all address busses used in SNAP are declared to be 64 bits wide (default is 32 bits). In the Synthesis tab, you can select the clock period (250MHz = 4ns) and the FPGA exact type used by the card you are working with (XCKU060).","title":"Understanding parameters preset by OC-Accel scripts"},{"location":"user-guide/7-build-image/","text":"Get started This is my start. I want it.","title":"(7) Build image"},{"location":"user-guide/7-build-image/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/8-deploy/","text":"Get started This is my start.","title":"(8) Deploy on Power Server"},{"location":"user-guide/8-deploy/#get-started","text":"This is my start.","title":"Get started"},{"location":"user-guide/9-migrate/","text":"Migrate from SNAP1.0/2.0 The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"(9) Migrate from SNAP1/2"},{"location":"user-guide/9-migrate/#migrate-from-snap1020","text":"The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"Migrate from SNAP1.0/2.0"}]}