{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenCAPI-SNAP Overview What is OpenCAPI OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium . What is SNAP The SNAP Framework enables programmers and computer engineers to quickly create FPGA-based acceleration actions that work on server host data, as well as data from storage, flash, Ethernet, or other connected resources. SNAP, therefore, is an acronym for \u201c S torage, N etwork, and A nalytics P rogramming\u201d. The OC-SNAP framework makes it easy to create accelerated actions utilizing OpenCAPI. What can I do with it SNAP helps you create an accelerator on a certain FPGA card. Refer to \"User Guide\" tab for a more detailed step-to-step guide. Preparation Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also named as \"action\" in the following description. Step1: Work on software part Put the action code into a function in the main software code, and determine the function parameters required. Add the few libosnap API functions that required to set up CAPI to the main software. Step2: Work on hardware part Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part done in above step, run a co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. Step3: Deploy to Power9! Program the bitstream to a real FPGA card plugged into a supported Power9 machine. Copy, compile and execute the source code of software part, and see the acceleration! SNAP Framework The framework hardware consists of a AXI-to-CAPI bridge unit, memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through AXI. Optionally, it also provides access to the on-card DRAM via AXI. A NVMe host controller-AXI bridge complements the framework for storage or database applications as an independent unit. Software gets access to the action through the libsnap library, allowing applications to call a \"function\" instead of programming an accelerator. The framework supports multi-process applications and can be extended to support multiple instantiated hardware actions in parallel. For more information, please refer to \"Deep Dive\" tab. Dependencies Machine and Tools for Development Development is usually done on a Linux (x86) computer . See examples of supported development configurations . The required tools and packages are listed below. Web access to github is recommended to follow the build instructions. A real FPGA card is not required for the plain hardware development. (a) Xilinx Vivado SNAP currently supports Xilinx FPGA devices, exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 tool suite is recommended. https://www.xilinx.com/products/design-tools/hardware-zone.html (b) OpenCAPI TlxDLx package (c) Build process Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the SNAP framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . (d) Run Simulation For simulation, SNAP relies on the xterm program. You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulations. Check Co-simulation for more information. Server and FPGA cards for Deployment (a) Supported Power9 servers Lagrange Chip based Monza Chip based (b) FPGA Card selection As of now, the following FPGA cards can be used with OC-SNAP: Alphadata 9V3 Compliance with SNAP1.0/2.0 https://github.com/open-power/snap has the SNAP framework for CAPI1.0 and CAPI2.0. Correspondingly, we call that repository SNAP1.0/2.0. This OC-SNAP framework has the similar structure, and the interfaces on \" Software Program \" and \" Hardware Action \" stay the same. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-SNAP directly without changing source-code. Check Migration Guide for more information. Read more This project is an initiative of the OpenPOWER Foundation Accelerator Workgroup. Please see here for more details: OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"About"},{"location":"#opencapi-snap-overview","text":"","title":"OpenCAPI-SNAP Overview"},{"location":"#what-is-opencapi","text":"OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogeneous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium .","title":"What is OpenCAPI"},{"location":"#what-is-snap","text":"The SNAP Framework enables programmers and computer engineers to quickly create FPGA-based acceleration actions that work on server host data, as well as data from storage, flash, Ethernet, or other connected resources. SNAP, therefore, is an acronym for \u201c S torage, N etwork, and A nalytics P rogramming\u201d. The OC-SNAP framework makes it easy to create accelerated actions utilizing OpenCAPI.","title":"What is SNAP"},{"location":"#what-can-i-do-with-it","text":"SNAP helps you create an accelerator on a certain FPGA card. Refer to \"User Guide\" tab for a more detailed step-to-step guide.","title":"What can I do with it"},{"location":"#preparation","text":"Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also named as \"action\" in the following description.","title":"Preparation"},{"location":"#step1-work-on-software-part","text":"Put the action code into a function in the main software code, and determine the function parameters required. Add the few libosnap API functions that required to set up CAPI to the main software.","title":"Step1: Work on software part"},{"location":"#step2-work-on-hardware-part","text":"Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part done in above step, run a co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream.","title":"Step2: Work on hardware part"},{"location":"#step3-deploy-to-power9","text":"Program the bitstream to a real FPGA card plugged into a supported Power9 machine. Copy, compile and execute the source code of software part, and see the acceleration!","title":"Step3: Deploy to Power9!"},{"location":"#snap-framework","text":"The framework hardware consists of a AXI-to-CAPI bridge unit, memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through AXI. Optionally, it also provides access to the on-card DRAM via AXI. A NVMe host controller-AXI bridge complements the framework for storage or database applications as an independent unit. Software gets access to the action through the libsnap library, allowing applications to call a \"function\" instead of programming an accelerator. The framework supports multi-process applications and can be extended to support multiple instantiated hardware actions in parallel. For more information, please refer to \"Deep Dive\" tab.","title":"SNAP Framework"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#machine-and-tools-for-development","text":"Development is usually done on a Linux (x86) computer . See examples of supported development configurations . The required tools and packages are listed below. Web access to github is recommended to follow the build instructions. A real FPGA card is not required for the plain hardware development.","title":"Machine and Tools for Development"},{"location":"#a-xilinx-vivado","text":"SNAP currently supports Xilinx FPGA devices, exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 tool suite is recommended. https://www.xilinx.com/products/design-tools/hardware-zone.html","title":"(a) Xilinx Vivado"},{"location":"#b-opencapi-tlxdlx-package","text":"","title":"(b) OpenCAPI TlxDLx package"},{"location":"#c-build-process","text":"Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the SNAP framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig .","title":"(c) Build process"},{"location":"#d-run-simulation","text":"For simulation, SNAP relies on the xterm program. You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulations. Check Co-simulation for more information.","title":"(d) Run Simulation"},{"location":"#server-and-fpga-cards-for-deployment","text":"","title":"Server and FPGA cards for Deployment"},{"location":"#a-supported-power9-servers","text":"Lagrange Chip based Monza Chip based","title":"(a) Supported Power9 servers"},{"location":"#b-fpga-card-selection","text":"As of now, the following FPGA cards can be used with OC-SNAP: Alphadata 9V3","title":"(b) FPGA Card selection"},{"location":"#compliance-with-snap1020","text":"https://github.com/open-power/snap has the SNAP framework for CAPI1.0 and CAPI2.0. Correspondingly, we call that repository SNAP1.0/2.0. This OC-SNAP framework has the similar structure, and the interfaces on \" Software Program \" and \" Hardware Action \" stay the same. Generally, your actions running on SNAP1.0/2.0 can be moved to OC-SNAP directly without changing source-code. Check Migration Guide for more information.","title":"Compliance with SNAP1.0/2.0"},{"location":"#read-more","text":"This project is an initiative of the OpenPOWER Foundation Accelerator Workgroup. Please see here for more details: OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Read more"},{"location":"actions-doc/hdl-example/","text":"hdl_example This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-example/#hdl_example","text":"This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-helloworld/","text":"hdl_helloworld A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hdl-helloworld/#hdl_helloworld","text":"A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hls-helloworld/","text":"hls_helloworld High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-helloworld/#hls_helloworld","text":"High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-memcopy/","text":"hls_memcopy This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"actions-doc/hls-memcopy/#hls_memcopy","text":"This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"deep-dive/board-package/","text":"Get started This is my start. I want it.","title":"New Board Support"},{"location":"deep-dive/board-package/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"deep-dive/hardware-logic/","text":"SNAP Hardware: logic design Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide . SNAP setup Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names. SNAP configuration In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration. SNAP environment variables A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names. Image and model build Specifying the action Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step. CAPI board support and PSL for image build In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0). POWER8 CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP. POWER9 CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl . The make process If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system. FPGA bitstream image update Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch. Action wrapper The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly. HDL Action In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content. HLS Actions The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ). SDRAM Card Memory The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'. NVMe support For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details. Hardware debug with ILA cores In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images . Cloud support TBD... Simulation see ./sim/README.md for further instructions about Simulation","title":"SNAP Hardware Logic"},{"location":"deep-dive/hardware-logic/#snap-hardware-logic-design","text":"Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide .","title":"SNAP Hardware: logic design"},{"location":"deep-dive/hardware-logic/#snap-setup","text":"Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names.","title":"SNAP setup"},{"location":"deep-dive/hardware-logic/#snap-configuration","text":"In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration.","title":"SNAP configuration"},{"location":"deep-dive/hardware-logic/#snap-environment-variables","text":"A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names.","title":"SNAP environment variables"},{"location":"deep-dive/hardware-logic/#image-and-model-build","text":"","title":"Image and model build"},{"location":"deep-dive/hardware-logic/#specifying-the-action","text":"Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step.","title":"Specifying the action"},{"location":"deep-dive/hardware-logic/#capi-board-support-and-psl-for-image-build","text":"In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0).","title":"CAPI board support and PSL for image build"},{"location":"deep-dive/hardware-logic/#power8","text":"CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP.","title":"POWER8"},{"location":"deep-dive/hardware-logic/#power9","text":"CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl .","title":"POWER9"},{"location":"deep-dive/hardware-logic/#the-make-process","text":"If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system.","title":"The make process"},{"location":"deep-dive/hardware-logic/#fpga-bitstream-image-update","text":"Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch.","title":"FPGA bitstream image update"},{"location":"deep-dive/hardware-logic/#action-wrapper","text":"The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly.","title":"Action wrapper"},{"location":"deep-dive/hardware-logic/#hdl-action","text":"In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content.","title":"HDL Action"},{"location":"deep-dive/hardware-logic/#hls-actions","text":"The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ).","title":"HLS Actions"},{"location":"deep-dive/hardware-logic/#sdram-card-memory","text":"The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'.","title":"SDRAM Card Memory"},{"location":"deep-dive/hardware-logic/#nvme-support","text":"For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details.","title":"NVMe support"},{"location":"deep-dive/hardware-logic/#hardware-debug-with-ila-cores","text":"In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images .","title":"Hardware debug with ILA cores"},{"location":"deep-dive/hardware-logic/#cloud-support","text":"TBD...","title":"Cloud support"},{"location":"deep-dive/hardware-logic/#simulation","text":"see ./sim/README.md for further instructions about Simulation","title":"Simulation"},{"location":"deep-dive/registers/","text":"SNAP Registers Overview SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers. Register Definition Impl. Version Register (IVR) Name Offset Description Implementation Version Register 0x0000 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31.. 0 RO First eight digits of SHA ID for commit Build Date Register (BDR) Name Offset Description Build Date Register 0x0008 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute) SNAP Command Register (SCR) Name Offset Description SNAP Command Register 0x0010 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47.. 8 RO Reserved 7.. 0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP SNAP Status Register (SSR) Name Offset Description SNAP Status Register 0x0018 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID SNAP Lock Register (SLR) Name Offset Description SNAP Lock Register 0x0020 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..1 RO Reserved 0 RW Lock (Set on Read) SNAP Capability Register (SCR) Name Offset Description SNAP Capability Register 0x0030 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3 Freerunning Timer (FRT) Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock Job Timeout Register (JTR) Name Offset Description Job Timeout Register 0x0088 POR value: 0x80000000_0ABA9500 timeout enabled with 1s Bitwise definition Bits Attributes Description 63 RW Enable Job Timeout checking (1=enabled) 62..32 RO Reserved 31..0 RW Job Timeout value (this value decrements with the 250MHz PSL clock) Action Active Counter (AAC) Name Offset Description Action Active Counter 0x0090 Counter counting the number of clock cycles with an active action Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles with an active action. (TBD: when is an action considered active?). This counter increments with the 250MHz PSL clock. Job Execution Counter (JEC) Name Offset Description Job Execution Counter 0x0098 Counter counting the number of clock cycles while a job gets executed Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles while a job gets executed (TBD: when is a job considered as being executed?). This counter increments with the 250MHz PSL clock. Context ID Register (CIR) Name Offset Description Context ID Register 0x00A0 Context ID in this register Bitwise definition Bits Attributes Description 63 RW Set to '1' for master register 0 for slave 62.. 0 RO Reserved (no context ID for master bit 63 = 1) 62.. 9 RO Reserved (if bit 63 = 0) 8.. 0 RO My context id (if bit 63 = 0). (9 bits corresponding to context IDs in the range 0..511) Action Type Register i (ATRi) Name Offset Description Action Type Register i (0 <= i < 16) 0x0100 + i * 0x008 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented) Context Attach Status Vector (CASV) Name Offset Description Context Attach Status Vector m (0 <= m < 16) 0xC000 + i * 0x008 Status of each context Bitwise definition Bits Attributes Description 63..32 RO Reserved 31..0 RO Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31). Job Work Timer (JWT) Name Offset Description Job Work Timer 0x00001080 + (s+n) * 0x0010000 Timer for each job Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles during job execution for this context. (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset). This counter increments with the 250MHz PSL clock. Context Configuration Register (CCR) Name Offset Description Context Configuration Register 0x1000 Configuration of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RW Context configuration: 0x01: Direct Mode 0x02: Rise IRQ when Action goes to IDLE 0x04: Rise IRQ when Action is attached Context Status Register Name Offset Description Context Status Register 0x1008 Status of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RO Context status: 0x80: Short Action Type for this context is assigned 0x40: This context is attached to an action 0x01: Currently executing job 0x00: Context Active Job Command Register (JCR) Name Offset Description Job Command Register 0x1010 Send command to a job Bitwise definition Bits Attributes Description 63..16 RO Reserved 15..0 RO Job command: 0x0004: Reset Action, than Detach action from context 0x0002: Detach action from context 0x0001: Attach action to context","title":"SNAP Registers"},{"location":"deep-dive/registers/#snap-registers","text":"","title":"SNAP Registers"},{"location":"deep-dive/registers/#overview","text":"SNAP registers are defined in the MMIO General space for each AFU. Action specific registers (registers related to AFU's function) are defined in the per PASID MMIO space. All of those address mapping parameters (BAR, MMIO general, MMIO PASID, and also memory space) are specified with respect to OpenCAPI configuration space specification. SNAP core hardware is responsible for handling the configuration read/write from host and maintaining the configuration space and SNAP registers.","title":"Overview"},{"location":"deep-dive/registers/#register-definition","text":"","title":"Register Definition"},{"location":"deep-dive/registers/#impl-version-register-ivr","text":"Name Offset Description Implementation Version Register 0x0000 POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Bitwise definition Bits Attributes Description 63..40 RO SNAP Release 63..56 RO Major release number 55..48 RO Intermediate release number 47..40 RO Minor release number 39..32 RO Distance of commit to SNAP release 31.. 0 RO First eight digits of SHA ID for commit","title":"Impl. Version Register (IVR)"},{"location":"deep-dive/registers/#build-date-register-bdr","text":"Name Offset Description Build Date Register 0x0008 POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 Bitwise definition Bits Attributes Description 63..48 RO Reserved 47.. 0 RO BCD coded build date and time 47..32 RO YYYY (year) 31..24 RO mm (month) 23..16 RO dd (day of month) 15..08 RO HH (hour) 07..00 RO MM (minute)","title":"Build Date Register (BDR)"},{"location":"deep-dive/registers/#snap-command-register-scr","text":"Name Offset Description SNAP Command Register 0x0010 Send SNAP commands via this register Bitwise definition Bits Attributes Description 63..48 RW Argument 47.. 8 RO Reserved 7.. 0 RW Command. Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register. Argument bits 63..52: Don't care. Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately. Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone). Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone). Argument: Don't care 0x00 NOP","title":"SNAP Command Register (SCR)"},{"location":"deep-dive/registers/#snap-status-register-ssr","text":"Name Offset Description SNAP Status Register 0x0018 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..9 RO Reserved 8 RO Exploration Done. This means that the ATRi setup is complete and the values are valid 7..4 RO Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO Maximum Action ID","title":"SNAP Status Register (SSR)"},{"location":"deep-dive/registers/#snap-lock-register-slr","text":"Name Offset Description SNAP Lock Register 0x0020 POR value: 0x0000000000000000 Bitwise definition Bits Attributes Description 63..1 RO Reserved 0 RW Lock (Set on Read)","title":"SNAP Lock Register (SLR)"},{"location":"deep-dive/registers/#snap-capability-register-scr","text":"Name Offset Description SNAP Capability Register 0x0030 Define the capability of the card Bitwise definition Bits Attributes Description 63..40 RO Reserved 39..36 RO Minimum size for DMA transfers to/from Host. Value t means that minimum transfer size is 2^t B 35..32 RO Data alignment for DMA transfers to/from Host. Value a means that transfers need to be 2^a B aligned 31..16 RO Size of attached on-card SDRAM in MB 15..9 RO Reserved 8 RO NVMe enabled 7..0 RO Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3","title":"SNAP Capability Register (SCR)"},{"location":"deep-dive/registers/#freerunning-timer-frt","text":"Name Offset Description Freerunning Timer 0x0080 Counting the number of clock cycles since reset Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles since reset (afu open). This counter increments with the 250MHz PSL clock","title":"Freerunning Timer (FRT)"},{"location":"deep-dive/registers/#job-timeout-register-jtr","text":"Name Offset Description Job Timeout Register 0x0088 POR value: 0x80000000_0ABA9500 timeout enabled with 1s Bitwise definition Bits Attributes Description 63 RW Enable Job Timeout checking (1=enabled) 62..32 RO Reserved 31..0 RW Job Timeout value (this value decrements with the 250MHz PSL clock)","title":"Job Timeout Register (JTR)"},{"location":"deep-dive/registers/#action-active-counter-aac","text":"Name Offset Description Action Active Counter 0x0090 Counter counting the number of clock cycles with an active action Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles with an active action. (TBD: when is an action considered active?). This counter increments with the 250MHz PSL clock.","title":"Action Active Counter (AAC)"},{"location":"deep-dive/registers/#job-execution-counter-jec","text":"Name Offset Description Job Execution Counter 0x0098 Counter counting the number of clock cycles while a job gets executed Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles while a job gets executed (TBD: when is a job considered as being executed?). This counter increments with the 250MHz PSL clock.","title":"Job Execution Counter (JEC)"},{"location":"deep-dive/registers/#context-id-register-cir","text":"Name Offset Description Context ID Register 0x00A0 Context ID in this register Bitwise definition Bits Attributes Description 63 RW Set to '1' for master register 0 for slave 62.. 0 RO Reserved (no context ID for master bit 63 = 1) 62.. 9 RO Reserved (if bit 63 = 0) 8.. 0 RO My context id (if bit 63 = 0). (9 bits corresponding to context IDs in the range 0..511)","title":"Context ID Register (CIR)"},{"location":"deep-dive/registers/#action-type-register-i-atri","text":"Name Offset Description Action Type Register i (0 <= i < 16) 0x0100 + i * 0x008 POR value: 0x00000000_00000000. LIBSNAP needs to specify the values based on the result of an exploration phase Bitwise definition Bits Attributes Description 63..36 RO Reserved 35..32 RW Internal Short Action Type 31.. 0 RW Action type for action i (all zero if no Action i is implemented)","title":"Action Type Register i (ATRi)"},{"location":"deep-dive/registers/#context-attach-status-vector-casv","text":"Name Offset Description Context Attach Status Vector m (0 <= m < 16) 0xC000 + i * 0x008 Status of each context Bitwise definition Bits Attributes Description 63..32 RO Reserved 31..0 RO Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31).","title":"Context Attach Status Vector (CASV)"},{"location":"deep-dive/registers/#job-work-timer-jwt","text":"Name Offset Description Job Work Timer 0x00001080 + (s+n) * 0x0010000 Timer for each job Bitwise definition Bits Attributes Description 63..0 RO Counter counting the number of clock cycles during job execution for this context. (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset). This counter increments with the 250MHz PSL clock.","title":"Job Work Timer (JWT)"},{"location":"deep-dive/registers/#context-configuration-register-ccr","text":"Name Offset Description Context Configuration Register 0x1000 Configuration of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RW Context configuration: 0x01: Direct Mode 0x02: Rise IRQ when Action goes to IDLE 0x04: Rise IRQ when Action is attached","title":"Context Configuration Register (CCR)"},{"location":"deep-dive/registers/#context-status-register","text":"Name Offset Description Context Status Register 0x1008 Status of each context Bitwise definition Bits Attributes Description 63..8 RO Reserved 7..0 RO Context status: 0x80: Short Action Type for this context is assigned 0x40: This context is attached to an action 0x01: Currently executing job 0x00: Context Active","title":"Context Status Register"},{"location":"deep-dive/registers/#job-command-register-jcr","text":"Name Offset Description Job Command Register 0x1010 Send command to a job Bitwise definition Bits Attributes Description 63..16 RO Reserved 15..0 RO Job command: 0x0004: Reset Action, than Detach action from context 0x0002: Detach action from context 0x0001: Attach action to context","title":"Job Command Register (JCR)"},{"location":"deep-dive/software-api/","text":"SNAP Software Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks. Environment Variables To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here. Directory Structure . |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"SNAP Software API"},{"location":"deep-dive/software-api/#snap-software","text":"Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks.","title":"SNAP Software"},{"location":"deep-dive/software-api/#environment-variables","text":"To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here.","title":"Environment Variables"},{"location":"deep-dive/software-api/#directory-structure","text":". |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Directory Structure"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . 4. Install Inkscape This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss. Website Structure First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them are created. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Use diagrams from PPT For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Code blocks and Admonitions Code blocks Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); } Admonitions You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs .","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-inkscape","text":"This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss.","title":"4. Install Inkscape"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. And please turn on the \"spell checking\" in your Markdown editor. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also simply copy paste pictures from clipboard and paste them. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them are created. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#use-diagrams-from-ppt","text":"For the diagrams from Microsoft PowerPoint, you can select the region of a diagram in PPT, Ctrl-C to copy it, and Ctrl-V to paste it in Typora directly. In this case, the diagram is saved as an PNG file. But there is a better way to get the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. Insert the SVG file into Typora. In my experiment, the PNG file is 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when zooming in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Use diagrams from PPT"},{"location":"misc/doc-guide/#code-blocks-and-admonitions","text":"","title":"Code blocks and Admonitions"},{"location":"misc/doc-guide/#code-blocks","text":"Please assign the code language so it can be correctly rendered. For example ``` C for C language. // A function to implement bubble sort void bubbleSort(int arr[], int n) { int i, j; for (i = 0; i < n-1; i++) // Last i elements are already in place for (j = 0; j < n-i-1; j++) if (arr[j] > arr[j+1]) swap(&arr[j], &arr[j+1]); }","title":"Code blocks"},{"location":"misc/doc-guide/#admonitions","text":"You can use !!! Note or !!! Warning or !!! Danger to start a paragraph of admonitions. Then use 4 spaces to start the admonition text. For example !!! Danger \"Error Message\" This is a dangerous error. It will be shown as: Error Message This is a dangerous error.","title":"Admonitions"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Deploy to Github Pages"},{"location":"user-guide/co-simulation/","text":"Get started This is my start. I want it.","title":"Co-Simulation"},{"location":"user-guide/co-simulation/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/command-reference/","text":"Get started This is my start. I want it.","title":"Command Reference"},{"location":"user-guide/command-reference/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/debug-issue/","text":"Get started This is my start.","title":"Debug an issue"},{"location":"user-guide/debug-issue/#get-started","text":"This is my start.","title":"Get started"},{"location":"user-guide/deploy/","text":"Get started This is my start. I want it.","title":"Deploy on Power Server"},{"location":"user-guide/deploy/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/make-image/","text":"Get started This is my start. I want it.","title":"FPGA Image build"},{"location":"user-guide/make-image/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/migrate-from-old/","text":"Migrate from SNAP1.0/2.0 The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"Migrate from SNAP1/2"},{"location":"user-guide/migrate-from-old/#migrate-from-snap1020","text":"The AXI data port width of OC-SNAP is 1024bit. But the actions developed in SNAP1.0 or SNAP2.0 use 512b for data-width. So you need to select a width-converter...","title":"Migrate from SNAP1.0/2.0"},{"location":"user-guide/new-action/","text":"Get started This is my start. I want it.","title":"Create a new action"},{"location":"user-guide/new-action/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/optimize-hls/","text":"Get started This is my start. I want it.","title":"Optimize HLS action"},{"location":"user-guide/optimize-hls/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/prepare-env/","text":"Prepare Environment Firstly, you need to have an x86 machine for developement. Check Tools Vivado xterm Simulators gcc Clone Repositories git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update Warning Please be aware of hardware/oc-bip. If you made changes in that submodule, please do remove the \"build\" directory manually. ( hardware/oc-bip/$CARD/oc-bsp/build ) Otherwise it will not be re-built automatically from the snap build scripts. git clone ocse!!!","title":"Prepare Environment"},{"location":"user-guide/prepare-env/#prepare-environment","text":"Firstly, you need to have an x86 machine for developement.","title":"Prepare Environment"},{"location":"user-guide/prepare-env/#check-tools","text":"","title":"Check Tools"},{"location":"user-guide/prepare-env/#vivado","text":"","title":"Vivado"},{"location":"user-guide/prepare-env/#xterm","text":"","title":"xterm"},{"location":"user-guide/prepare-env/#simulators","text":"","title":"Simulators"},{"location":"user-guide/prepare-env/#gcc","text":"","title":"gcc"},{"location":"user-guide/prepare-env/#clone-repositories","text":"git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update Warning Please be aware of hardware/oc-bip. If you made changes in that submodule, please do remove the \"build\" directory manually. ( hardware/oc-bip/$CARD/oc-bsp/build ) Otherwise it will not be re-built automatically from the snap build scripts. git clone ocse!!!","title":"Clone Repositories"},{"location":"user-guide/run-example/","text":"Get started This is my start. I want it.","title":"Run an example"},{"location":"user-guide/run-example/#get-started","text":"This is my start. I want it.","title":"Get started"}]}