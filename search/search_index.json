{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OpenCAPI-SNAP Overview What is OpenCAPI OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogenerous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium . What is SNAP The SNAP Framework enables programmers and computer engineers to quickly create FPGA-based acceleration actions that work on server host data, as well as data from storage, flash, Ethernet, or other connected resources. SNAP, therefore, is an acronym for \u201c S torage, N etwork, and A nalytics P rogramming\u201d. The OC-SNAP framework makes it easy to create accelerated actions utilizing OpenCAPI. What can I do with it SNAP helps you create an accelerator on a certain FPGA card. Refer to \"User Guide\" tab for a more detailed step-to-step guide. Preparation Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also named as \"action\" in the following description. Step1: Work on software part Put the action code into a function in the main software code, and determine the function parameters required. Add the few libosnap API functions that required to set up CAPI to the main software. Step2: Work on hardware part Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part done in above step, run a co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream. Step3: Deploy to Power9! Program the bitstream to a real FPGA card plugged into a supported Power9 machine. Copy, compile and execute the source code of software part, and see the acceleration! SNAP Framework The framework hardware consists of a AXI-to-CAPI bridge unit, memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through AXI. Optionally, it also provides access to the on-card DRAM via AXI. A NVMe host controller-AXI bridge complements the framework for storage or database applications as an independent unit. Software gets access to the action through the libsnap library, allowing applications to call a \"function\" instead of programming an accelerator. The framework supports multi-process applications and can be extended to support multiple instantiated hardware actions in parallel. For more information, please refer to \"Deep Dive\" tab. Dependencies Machine and Tools for Development Development is usually done on a Linux (x86) computer . See examples of supported development configurations . The required tools and packages are listed below. Web access to github is recommended to follow the build instructions. A real FPGA card is not required for the plain hardware development. (a) Xilinx Vivado SNAP currently supports Xilinx FPGA devices, exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 tool suite is recommended. https://www.xilinx.com/products/design-tools/hardware-zone.html (b) OpenCAPI TlxDLx package (c) Build process Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the SNAP framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig . (d) Run Simulation For simulation, SNAP relies on the xterm program. You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulations. Check Co-simulation for more information. Server and FPGA cards for Deployment (a) Supported Power9 servers Lagrange Chip based Monza Chip based (b) FPGA Card selection As of now, the following FPGA cards can be used with OC-SNAP: Alphadata 9V3 Compliance with CAPI1.0/2.0 Currently the SNAP Framework supports CAPI1.0 on POWER8 based hosts and CAPI2.0 on POWER9 based hosts. A similar OpenCAPI SNAP framework is going to be added in a new repository. Users working on SNAP today can easily transfer their CAPI1.0 work to CAPI2.0 or OpenCAPI as the interface for \" Software Program \" and \" Hardware Action \" (shown in the yellow areas of the above figure) will stay the same. Read more This project is an initiative of the OpenPOWER Foundation Accelerator Workgroup. Please see here for more details: OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"About"},{"location":"#opencapi-snap-overview","text":"","title":"OpenCAPI-SNAP Overview"},{"location":"#what-is-opencapi","text":"OpenCAPI (Open Coherent Accelerator Processor Interface) is an open coherent high performance bus interface based on a new bus standard. Driven by the emerging accelerated heterogenerous computing and advanced memory/storage solutions, It provides an Open Interface Architecture that allows any microprocessor to attach to Coherent user-level accelerators and I/O devices Advanced memories accessible via read/write or user-level DMA semantics Its specifications and ecosystem are managed by an open forum OpenCAPI Consortium .","title":"What is OpenCAPI"},{"location":"#what-is-snap","text":"The SNAP Framework enables programmers and computer engineers to quickly create FPGA-based acceleration actions that work on server host data, as well as data from storage, flash, Ethernet, or other connected resources. SNAP, therefore, is an acronym for \u201c S torage, N etwork, and A nalytics P rogramming\u201d. The OC-SNAP framework makes it easy to create accelerated actions utilizing OpenCAPI.","title":"What is SNAP"},{"location":"#what-can-i-do-with-it","text":"SNAP helps you create an accelerator on a certain FPGA card. Refer to \"User Guide\" tab for a more detailed step-to-step guide.","title":"What can I do with it"},{"location":"#preparation","text":"Find out the \"hot-spot\" function to be moved to FPGA. This function, usually computation intensive, is also named as \"action\" in the following description.","title":"Preparation"},{"location":"#step1-work-on-software-part","text":"Put the action code into a function in the main software code, and determine the function parameters required. Add the few libosnap API functions that required to set up CAPI to the main software.","title":"Step1: Work on software part"},{"location":"#step2-work-on-hardware-part","text":"Write the \"hardware action\" in a supported programming language, such as Vivado HLS or Verilog/VHDL. Together with the software part done in above step, run a co-simulation to verify the correctness. After the co-simulation is done, generate the FPGA bitstream.","title":"Step2: Work on hardware part"},{"location":"#step3-deploy-to-power9","text":"Program the bitstream to a real FPGA card plugged into a supported Power9 machine. Copy, compile and execute the source code of software part, and see the acceleration!","title":"Step3: Deploy to Power9!"},{"location":"#snap-framework","text":"The framework hardware consists of a AXI-to-CAPI bridge unit, memory-mapped register I/O, host DMA, and a job management unit. It interfaces with a user-written action (a.k.a. kernel) through an AXI-lite control interface, and gives coherent access to host memory through AXI. Optionally, it also provides access to the on-card DRAM via AXI. A NVMe host controller-AXI bridge complements the framework for storage or database applications as an independent unit. Software gets access to the action through the libsnap library, allowing applications to call a \"function\" instead of programming an accelerator. The framework supports multi-process applications and can be extended to support multiple instantiated hardware actions in parallel. For more information, please refer to \"Deep Dive\" tab.","title":"SNAP Framework"},{"location":"#dependencies","text":"","title":"Dependencies"},{"location":"#machine-and-tools-for-development","text":"Development is usually done on a Linux (x86) computer . See examples of supported development configurations . The required tools and packages are listed below. Web access to github is recommended to follow the build instructions. A real FPGA card is not required for the plain hardware development.","title":"Machine and Tools for Development"},{"location":"#a-xilinx-vivado","text":"SNAP currently supports Xilinx FPGA devices, exclusively. For synthesis, simulation model and image build, the Xilinx Vivado 2018.2 tool suite is recommended. https://www.xilinx.com/products/design-tools/hardware-zone.html","title":"(a) Xilinx Vivado"},{"location":"#b-opencapi-tlxdlx-package","text":"","title":"(b) OpenCAPI TlxDLx package"},{"location":"#c-build-process","text":"Building the code and running the make environment requires the usual development tools gcc, make, sed, awk . If not installed already, the installer package build-essential will set up the most important tools. Configuring the SNAP framework will call a standalone tool that is based on the Linux kernel kconfig tool. The ncurses library must be installed to use the menu-driven user interface for kconfig .","title":"(c) Build process"},{"location":"#d-run-simulation","text":"For simulation, SNAP relies on the xterm program. You can use the build-in simulation xsim from Xilinx Vivado, or you can also use other simulations. Check Co-simulation for more information.","title":"(d) Run Simulation"},{"location":"#server-and-fpga-cards-for-deployment","text":"","title":"Server and FPGA cards for Deployment"},{"location":"#a-supported-power9-servers","text":"Lagrange Chip based Monza Chip based","title":"(a) Supported Power9 servers"},{"location":"#b-fpga-card-selection","text":"As of now, the following FPGA cards can be used with OC-SNAP: Alphadata 9V3","title":"(b) FPGA Card selection"},{"location":"#compliance-with-capi1020","text":"Currently the SNAP Framework supports CAPI1.0 on POWER8 based hosts and CAPI2.0 on POWER9 based hosts. A similar OpenCAPI SNAP framework is going to be added in a new repository. Users working on SNAP today can easily transfer their CAPI1.0 work to CAPI2.0 or OpenCAPI as the interface for \" Software Program \" and \" Hardware Action \" (shown in the yellow areas of the above figure) will stay the same.","title":"Compliance with CAPI1.0/2.0"},{"location":"#read-more","text":"This project is an initiative of the OpenPOWER Foundation Accelerator Workgroup. Please see here for more details: OpenPower Foundation Acceleration Group CAPI drives business performance CAPI and SNAP on IBM developerworks Education Videos","title":"Read more"},{"location":"actions-doc/hdl-example/","text":"hdl_example This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-example/#hdl_example","text":"This is the action for SNAP sanity tests. | \u2502 Makefile General Makefile used to automatically prepare the final files \u2502 README.md General documentation file for this example \u2502 \u251c\u2500\u2500\u2500doc Detailed documentation directory \u2502 README.md This file ! \u2502 \u251c\u2500\u2500\u2500hw Hardware directory containing all VHDL related items \u2502 action_axi_master.vhd AXI Master used to transfer data to/from host through PSL(CAPI) \u2502 action_axi_nvme.vhd AXI Master attached to the NVMe Controller \u2502 action_axi_slave.vhd AXI slave used to configure control registers \u2502 action_config.sh Used to selectively connect hardware drivers \u2502 action_example.vhd This file is the result of the make process (once source files have been used) \u2502 action_example.vhd_source Source file for the generation of action_example.vhd enabling only the configured | hardware options \u2502 action_wrapper.vhd_source Wrapper connecting the action with the SNAP framework \u2502 Makefile Makefile used to automatically and selectively prepare the .vhd hardware files \u2502 \u251c\u2500\u2500\u2500sw Software directory containing the application called from POWER host \u2502 Makefile \u2502 snap_example.c Basic application (runs on POWER) including several examples (counter, memory | transfers, etc ...) \u2502 snap_example.h \u2502 snap_example_ddr.c TBD \u2502 snap_example_nvme.c TBD \u2502 snap_example_qnvme.c TBD \u2502 snap_example_set.c TBD \u2502 \u2514\u2500\u2500\u2500tests Test directory containing all automated tests 10140000_ddr_test.sh Basic test shell running snap_example application 10140000_kill_test.sh Basic test shell used to test unexpected action interruption 10140000_nvme_test.sh Basic test shell running snap_example_nvme application 10140000_set_test.sh Basic test shell running snap_example_set application 10140000_test.sh Basic test shell running snap_example application README.md TBD","title":"hdl_example"},{"location":"actions-doc/hdl-helloworld/","text":"hdl_helloworld A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hdl-helloworld/#hdl_helloworld","text":"A very simple example to interface with AXI-lite slave and AXI-master.","title":"hdl_helloworld"},{"location":"actions-doc/hls-helloworld/","text":"hls_helloworld High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-helloworld/#hls_helloworld","text":"High Level Synthesis example.","title":"hls_helloworld"},{"location":"actions-doc/hls-memcopy/","text":"hls_memcopy This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"actions-doc/hls-memcopy/#hls_memcopy","text":"This is an action using HLS. Also used to test the throughtput of Host <-> FPGA FPGA <-> Card DRAM","title":"hls_memcopy"},{"location":"deep-dive/board-package/","text":"Get started This is my start. I want it.","title":"New Board Support"},{"location":"deep-dive/board-package/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"deep-dive/hardware-logic/","text":"SNAP Hardware: logic design Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide . SNAP setup Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names. SNAP configuration In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration. SNAP environment variables A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names. Image and model build Specifying the action Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step. CAPI board support and PSL for image build In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0). POWER8 CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP. POWER9 CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl . The make process If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system. FPGA bitstream image update Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch. Action wrapper The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly. HDL Action In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content. HLS Actions The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ). SDRAM Card Memory The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'. NVMe support For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details. Hardware debug with ILA cores In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images . Cloud support TBD... Simulation see ./sim/README.md for further instructions about Simulation","title":"SNAP Hardware Logic"},{"location":"deep-dive/hardware-logic/#snap-hardware-logic-design","text":"Warning This is an initial version copied from SNAP1/2. Most of the content should be moved to User-guide .","title":"SNAP Hardware: logic design"},{"location":"deep-dive/hardware-logic/#snap-setup","text":"Please check ../README.md for dependencies . Executing the following commands is pre-requisite for the usage of the SNAP framework: source <xilinx_root>/Vivado/<version>/settings64.sh export XILINXD_LICENSE_FILE=<pointer to Xilinx license> In order to handle paths and other environment settings, the SNAP make process is always sourcing the script ${SNAP_ROOT}/snap_env.sh . You may modify that script (or create it if it doesn't already exist) and add your environment settings to that script (see also SNAP environment variables ). Note: The SNAP make process is internally defining a variable ${SNAP_ROOT} which is pointing to SNAP's root directory . Therefore, this variable may be used in the specification of paths for the make process, and we are using this variable in this document in the notation of file names.","title":"SNAP setup"},{"location":"deep-dive/hardware-logic/#snap-configuration","text":"In order to configure the SNAP framework and to prepare the environment for the SNAP build process, you may call make snap_config from the SNAP root directory. Making use of a standalone application configuration tool based on kernel kconfig the features for a specific SNAP framework configuration can be selected. Among the features that get configured via make snap_config are the card type the action type (see also Specifying the action ) enablement of the on-card SDRAM enablement of the Xilinx Integrated Logic Analyzer * the simulator If additional path settings are required, the step make snap_config will tell you which variable definitions to add to the script ${SNAP_ROOT}/snap_env.sh (see also SNAP environment variables ). By calling make snap_config again, a previously defined configuration may be modified. If you want to clean your repository (i.e. remove the generated files) you may do so by calling make clean But, that call will keep the configuration settings. If you want to also reset the configuration settings you may call make clean_config It is recommended to call make clean_config each time you want to start over with a new configuration.","title":"SNAP configuration"},{"location":"deep-dive/hardware-logic/#snap-environment-variables","text":"A side effect of calling make snap_config is the modification (or creation in case of first time execution) of the file ${SNAP_ROOT}/snap_env.sh . The main purpose of this file is the definition of paths that are required during the SNAP build and simulation process. The file gets sourced during SNAP's make process. As a result of the execution of make snap_config a version of ${SNAP_ROOT}/snap_env.sh containing at least five (maybe commented and incomplete) lines will exist: export TIMING_LABLIMIT=<lower slack limit for timing considered acceptable for bitstream build> export ACTION_ROOT=<pointer to the directory containing the action sources> export PSLVER='8: PSL version for POWER8 | 9: PSL version for POWER9' export PSL_DCP=[pointer to the Vivado CAPI PSL design checkpoint file (b_route_design.dcp)] export PSLSE_ROOT=<pointer to the path containing the PSLSE github clone> If a file ${SNAP_ROOT}/snap_env.sh is already existing when calling make snap_config that file will be taken, and the definition of ACTION_ROOT will be adapted according to the selection of the action type. In case of a setup for cloud builds (see Cloud Support ) the following setup will be modified as well: DCP_ROOT=<pointer to the directory for design checkpoints required in the Partial Reconfiguration flow> As already indicated above, the notation ${SNAP_ROOT} may be used when pointing to directories or files below the SNAP root directory. For instance, if during the make snap_config step you select hdl_example as action the file ${SNAP_ROOT}/snap_env.sh will contain the line export ACTION_ROOT=${SNAP_ROOT}/actions/hdl_example Note: When calling make snap_config for the first time without a given ${SNAP_ROOT}/snap_env.sh , you need to edit the generated file ${SNAP_ROOT}/snap_env.sh in order to set the correct path names.","title":"SNAP environment variables"},{"location":"deep-dive/hardware-logic/#image-and-model-build","text":"","title":"Image and model build"},{"location":"deep-dive/hardware-logic/#specifying-the-action","text":"Which action is getting integrated into the SNAP framework is specified in ${SNAP_ROOT}/snap_env.sh via the path ACTION_ROOT . When selecting \"HDL Action\" or \"HLS Action\" (for example when creating your own new action), the variable ACTION_ROOT is either set to an empty string or to the value that was selected in the previous run of make snap_config . You may simply modify the file ${SNAP_ROOT}/snap_env.sh manually to let ACTION_ROOT point to the directory containing the action. As part of the Vivado project configuration step, the make process will call the target hw that is expected to exist in a Makefile contained in the directory that ACTION_ROOT is pointing to (see section Action wrapper ). Specific configurations/preparations for the action may be added via this make process step.","title":"Specifying the action"},{"location":"deep-dive/hardware-logic/#capi-board-support-and-psl-for-image-build","text":"In order to benefit from the advantage of CAPI (low latency high bandwith access to host memory as well as memory coherency) a specific implementation of the FPGA is required to use the PCIe link and CAPP ( C oherent A ccelerator P rocessor P roxy which is located in the POWER processor) properly. The PSL ( P OWER S ervice L ayer) is providing the necessary infrastructure. The PSL differs whether we have a POWER8 with CAPI 1.0 or a POWER9 with CAPI 2.0. In any case, to get the latest CAPI board support and PSL download, visit IBM Portal for OpenPOWER at https://www.ibm.com/systems/power/openpower From the menu, select \"CAPI\"->\"Coherent Accelerator Processor Interface (CAPI)\" or directly click the \"CAPI\" icon to go to the CAPI section. Then download the appropriate files depending on your target system being POWER8 (CAPI 1.0) or POWER9 (CAPI 2.0).","title":"CAPI board support and PSL for image build"},{"location":"deep-dive/hardware-logic/#power8","text":"CAPI board support and PSL are provided combined in a Vivado DCP ( D esign C heck P oint). Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL Checkpoint Files for the POWER8 CAPI SNAP Design Kit \" according to the selected FPGA card. For the image build process you need to make sure that in snap_env.sh the environment variable PSL_DCP is defined such that it is pointing to the downloaded Vivado DCP.","title":"POWER8"},{"location":"deep-dive/hardware-logic/#power9","text":"CAPI BSP ( B oard S upport P ackage) and PSL got separated. For the CAPI 2.0 BSP, the open source git repository https://github.com/open-power/capi2-bsp is integrated into the SNAP framework as git submodule under hardware/capi2-bsp . The PSL is integrated into the CAPI BSP as an IP core with encrypted sources. Please go to the IBM Portal for OpenPOWER and download the required files under \" PSL IP Source Files for POWER9 CAPI \". Alternatively, the following link will provide direct access: https://www-355.ibm.com/systems/power/openpower/posting.xhtml?postingId=1BED44BCA884D845852582B70076A89A If the environment variable PSL9_IP_CORE is defined (e.g. via snap_env.sh ), the build process uses it as a pointer to the archived PSL9 IP core. Otherwise, the build process is assuming the archived PSL9 IP core is located in the directory snap/hardware/capi2-bsp/psl .","title":"POWER9"},{"location":"deep-dive/hardware-logic/#the-make-process","text":"If you call make without any targets, then a help message will be printed explaining the different targets supported by the make process. A simulation model (for the simulator defined in the snap_config step) may be created via the target model : make model This will also build the software tools and the PSLSE which are required to run the simulation. If you want to build an image (a bitstream), you may call make with target image : make image Note: You must still build the software tools on the POWER target system.","title":"The make process"},{"location":"deep-dive/hardware-logic/#fpga-bitstream-image-update","text":"Please see snap/hardware/doc/Bitstream_flashing.md for instructions on how to update the FPGA bitstream image, build factory images and program cards from scratch.","title":"FPGA bitstream image update"},{"location":"deep-dive/hardware-logic/#action-wrapper","text":"The definition of ACTION_ROOT in ${SNAP_ROOT}/snap_env.sh specifies the path to the set of actions that shall be included. It has to point to a directory within snap/actions . The SNAP hardware build process is expecting each action example's root directory to contain a Makefile providing at least the targets clean and hw (see also snap/actions/README.md ). At this point SNAP supports the integration of one action. Multi-action support will follow. Corresponding to the ports that the SNAP framework provides, each action has to provide ports for the following AXI interfaces: an AXI slave port for MMIO based control an AXI master port for host DMA traffic an optional AXI master port for on-card SDRAM traffic an optional AXI master port for communication with an NVMe host controller Furthermore, HDL actions have to implement the interrupt ports as shown in the HDL example action wrapper . For HLS actions, the HLS compiler will automatically generate the necessary interrupt logic. Note that the ID widths of the AXI interfaces to host memory and to the on-card SDRAM have to be large enough to support the number of actions that shall be instantiated. For the build process this is controlled via the option NUM_OF_ACTIONS which is configurable in the make snap_config step. Note * The SNAP framework currently does not support more than one action. The support for actions created with HLS as opposed to HDL actions written directly in VHDL or Verilog differs slightly.","title":"Action wrapper"},{"location":"deep-dive/hardware-logic/#hdl-action","text":"In order to integrate an HDL action into the SNAP framework the directory that ACTION_ROOT is pointing to, needs to contain an entity named action_wrapper which is serving as interface between the action and the SNAP framework. An example for such an action together with a corresponding wrapper may be found in snap/actions/hdl_example/hw . It can be used for various verification scenarios like copying memory content.","title":"HDL Action"},{"location":"deep-dive/hardware-logic/#hls-actions","text":"The top level entity for an HLS action needs to be named hls_action . You'll also find examples for HLS actions in snap/actions . For each example, the HLS action to be integrated into the SNAP framework is contained in a file hls_<action>.cpp . Before initiating the SNAP framework's make process, you need to create the necessary RTL files (VHDL or Verilog) out of the hls_<action>.cpp file. Each example contains a Makefile that takes care of this. In order to make sure that the resulting top level entity fits into the SNAP framework, the HLS actions top level function needs to be named hls_action . The variable ACTION_ROOT needs to point to a subdirectory of snap/actions . That directory should contain a Makefile for generating the RTL code from the HLS .cpp sources. As shown in the examples, the Makefile should include the file snap/actions/hls.mk . That way the RTL code for the HLS action will be placed into a subdirectory hw contained in the directory that $ACTION_ROOT points to, and the SNAP framework's make process is able to include it. Example: By setting up ${SNAP_ROOT}/snap_env.sh such that ACTION_ROOT points to ${SNAP_ROOT}/actions/hls_memcopy the HLS memcopy example contained in snap/actions/hls_memcopy will get integrated into the SNAP framework. Note: For the integration of HLS actions into the SNAP framework, ACTION_ROOT needs to point to (a subdirectory of) a directory starting with hls (case doesn't matter), or the environment variable $HLS_SUPPORT needs to be defined and to be set to TRUE (this is an option that is handled during the environment setup via make snap_config ).","title":"HLS Actions"},{"location":"deep-dive/hardware-logic/#sdram-card-memory","text":"The SNAP framework supports the usage of the on-card SDRAM. It is accessible for the actions via the action wrapper through an AXI master interface. In the SNAP configuration step the existence of that interface is controlled via the option 'Enable SDRAM'.","title":"SDRAM Card Memory"},{"location":"deep-dive/hardware-logic/#nvme-support","text":"For FPGA cards with NVMe flash attached, the SNAP framework supports the integration of up to two Flash drives. Via the SNAP configuration option 'Enable NVMe' the instantiation of the NVMe host controller together with the corresponding PCIe root complexes and the required AXI interfaces can be configured. The actions directory contains HDL and HLS based examples on how to use NVMe: - snap/actions/hdl_example provides automated data checking (read and write of arbitrary data) - snap/actions/hdl_nvme_example shows file transfers using fixed 4k block reads and writes - snap/actions/hls_nvme_memcopy implements a generic HLS memcopy function Note the data itself doesn't flow through the NVMe host controller, but transits through the on-card SDRAM. Please see the NVMe main documentation page for more details.","title":"NVMe support"},{"location":"deep-dive/hardware-logic/#hardware-debug-with-ila-cores","text":"In order to create an image that allows debugging the design using the Vivado Integrated Logic Analyzer (ILA) you may prepare a .xdc file for adding ILA cores to the design (an example for such a file is located here: ./doc/ila_debug.xdc ). Enabling ILA_DEBUG in the SNAP configuration and defining the environment variable ILA_SETUP_FILE in ${SNAP_ROOT}/snap_env.sh such that it points to a .xdc file with ILA core definitions, will configure the preparation of the ILA cores during the image build process. Additionally to the image files itself, the build process will create the required .ltx debug probes file which will be located in the results directory ${SNAP_ROOT}/hardware/build/Images .","title":"Hardware debug with ILA cores"},{"location":"deep-dive/hardware-logic/#cloud-support","text":"TBD...","title":"Cloud support"},{"location":"deep-dive/hardware-logic/#simulation","text":"see ./sim/README.md for further instructions about Simulation","title":"Simulation"},{"location":"deep-dive/registers/","text":"SNAP Registers Warning OpenCAPI doesn't have the concept of Master-context and Slave-context. The register definitions may have a big change. MMIO-MAP - Master Space While the master context has access to the whole MMIO space the first 32MB of the MMIO space are accessible by the master exclusively (with s = 512 this is corresponding to the address range below s * 0x0010000). The Framework Control and Status registers (aka Master PSA registers) are 8B registers. All the other registers are 4B wide. Address ========= ======================================== 0x0000000 | | | Master Context | ... | Framework Control & Status | | (64KB) | 0x000FFF8 | | ======================================== 0x0010000 | | ... | Action 0x0 (4KB) | 0x0010FFC | | ==================== 0x0011000 | | ... | Action 0x1 (4KB) | 0x0011FFC | | ==================== 0x0012000 | | ... | Action 0x2 (4KB) | 0x0012FFC | | ==================== ... ==================== 0x001F000 | | ... | Action 0xF (4KB) | 0x001FFFC | | ==================== 0x0020000 | | | NVME | ... | Config & Admin | | (128KB) | 0x003FFFC | | ==================== MMIO-MAP Slave Context Each slave context has access to its own 64KB MMIO space only via the address offset. PSL is adding the base address which is (s+n)*0x0010000 where s is 512 and n is the context id. The MMIO space of the action attached to the context is mapped into the last 4KB of the slave context space. The Framework Control and Status registers (aka Slave PSA) are 8B registers. The action's registers are 4B wide. The master context has access to each slave context space. Address map for context n (0 <= n < 512), and with s = 512: Base Offset ============================= ======================================== (s+n)*0x0010000 + 0x0000000 | | | Slave Context n | ... | Framework Control & Status | | (60KB) | (s+n)*0x0010000 + 0x000EFF8 | | ======================================== (s+n)*0x0010000 + 0x000F000 | | ... | Action (4KB) | (s+n)*0x0010000 + 0x000FFFC | | ==================== SNAP Framework Register Specifications RW = Read/Write RO = Read only - Reserved bits return 0 unless specified otherwise RC = Read only with clear on read RWC = Read/WriteClear (Write clears (=>0) the bits for each bit=1 in the write value) RWS = Read/WriteSet (Write sets (=>1) the bits for each bit=1 in the write value) n = Context Handle (aka. Process ID; 0 <= n < number of processes) Master PSA Implementation Version Register (IVR) Address: 0x0000000 63..40 RO: SNAP Release 63..56: Major release number 55..48: Intermediate release number 47..40: Minor release number 39..32 RO: Distance of commit to SNAP release 31..0 RO: First eight digits of SHA ID for commit POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Build Date Register (BDR) Address: 0x0000008 63..48 RO: Reserved 47..0 RO: BCD coded build date and time 47..32: YYYY (year) 31..24: mm (month) 23..16: dd (day of month) 15..08: HH (hour) 07..00: MM (minute) POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 SNAP Command Register (SCR) (commands \\<Reset>, \\<Abort> are not yet implemented) Address: 0x0000010 63..48 RW: Argument 47..8 RO: Reserved 7..0 RW: Command Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register Argument bits 63..52: Don't care Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone) Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone) Argument: Don't care 0x00 NOP SNAP Status Register (SSR) Address: 0x0000018 63..9 RO: Reserved 8 RO: Exploration Done This means that the ATRi setup is complete and the values are valid 7..4 RO: Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO: Maximum Action ID POR value: 0x000000000000000a with a = maximum action ID for this card build SNAP Lock Register (SLR) Address: 0x0000020 63..1 RO: Reserved 0 RW: Lock (Set on Read) POR value: 0x0000000000000000 SNAP Reset Control Register (SRC) Address: 0x0000028 63..5 RO: Reserved 4 RW: Reset PCIe core and NVMe drives '1' : keep RESET active 3..0 RW: Reset NVMe drives via the four M2_PERST_N pins Bit i='1' : pull down M2_PERST_N(i) POR value: 0x0000000000000000 SNAP Capability Register (SCaR) Address: 0x0000030 63..40 RO: Reserved 39..36 RO: Minimum size for DMA transfers to/from Host Value t means that minimum transfer size is 2^t B 35..32 RO: Data alignment for DMA transfers to/from Host Value a means that transfers need to be 2^a B aligned 31..16 RO: Size of attached on-card SDRAM in MB 15..9 RO: Reserved 8 RO: NVMe enabled 7..0 RO: Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3 Freerunning Timer (FRT) Address: 0x0000080 63..0 RO: Counter counting the number of clock cycles since reset (afu open) This counter increments with the 250MHz PSL clock. Job Timeout Register (JTR) Not yet implemented (required ??? for all contexts ???) Address: 0x0000088 63 RW: Enable Job Timeout checking (1=enabled) 62..32 RO: Reserved 31..0 RW: Job Timeout value (this value decrements with the 250MHz PSL clock) POR value: 0x80000000_0ABA9500 timeout enabled with 1s Action Active Counter (AAC) Not yet implemented (required ???) Address: 0x0000090 63..0 RO: Counter counting the number of clock cycles while an action is active This counter increments with the 250MHz PSL clock. Context Execution Counter (CEC) Not yet implemented (required ???) Address: 0x0000098 63..0 RO: Counter counting the number of clock cycles while a job gets executed on the card This counter increments with the 250MHz PSL clock. Context ID Register (CIR) Address: 0x00000A0 63 RO: Set to '1' for master register 62..0 RO: Reserved (no context ID for master) Action Type Register i (ATRi) (0 <= i < 16) Address: 0x0000100 + i * 0x0000008 63..36 RO: Reserved 35..32 RW: Internal Short Action Type 31..0 RW: Action type for action i (all zero if no Action i is implemented) POR value: 0x00000000_00000000 LIBSNAP needs to specify the values based on the result of an exploration phase Action Counter Register i (ACRi) (0 <= i < 16) Address: 0x0000180 + i * 0x0000008 63..0 RW: Cumulative counter counting the number of clock cycles while action i is active This counter increments with the 250MHz PSL clock. It can be reset or preset to any value by the master. POR value: 0x00000000_00000000 Context Attach Status Vector (CASV) Not yet implemented (required ???) Address: 0x00C000 + m * 0x0000008 (m = 0,..,15) 63..32 RO: Reserved 31..0 RO: Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31). SNAP Debug Register (SDR) Address: 0x000D000 63..1 RO: Reserved 0 RW: Enable PSL parity checking via AFU Control Interface to PSL '1': Parity checking is enabled '0': Parity checking is disabled (default value) POR value: 0x00000000_00000000 SNAP NVMe Register (SNR) Address: 0x000D008 63..0 RW: Reserved for NVMe usage POR value: 0x00000000_00000000 Job-Manager FIRs Not yet implemented Address: 0x000E000 63..6 RO: Reserved 5 RWC: EA Parity Error 4 RWC: COM Parity Error 3 RWC: DDCB Read FSM Error 2 RWC: DDCB Queue Control FSM Error 1 RWC: Job Control FSM Error 0 RWC: Context Control FSM Error MMIO FIRs Not yet implemented Address: 0x000E008 63..10 RO: Reserved 9 RWC: MMIO DDCBQ Work-Timer RAM Parity Error 8 RWC: MMIO DDCBQ DMA-Error RAM Parity Error 7 RWC: MMIO DDCBQ Last Sequence Number RAM Parity Error 6 RWC: MMIO DDCBQ Index and Sequence Number RAM Parity Error 5 RWC: MMIO DDCBQ Non-Fatal-Error RAM Parity Error 4 RWC: MMIO DDCBQ Status RAM Parity Error 3 RWC: MMIO DDCBQ Config RAM Parity Error 2 RWC: MMIO DDCBQ Start Pointer RAM Parity Error 1 RWC: MMIO Write Address Parity Error 0 RWC: MMIO Write Data Parity Error DMA FIRs Not yet implemented Address: 0x000E010 63..10 RO: Reserved 9 RWC: DMA Aligner Write FSM Error 8 RWC: DMA Aligner Read FSM Error 7 RO: Reserved 6 RWC: HA Buffer Interface Write Data Error 5 RWC: HA Buffer Interface Write Tag Error 4 RWC: HA Buffer Interface Read TAG Error 3 RWC: HA Response Interface Tag Error 2 RWC: DMA Write Control FSM Error 1 RWC: DMA Read Control FSM Error 0 RWC: AH Command FSM Error Action i FIRs Not yet implemented Address: 0x000E100 + i * 0x0000008 63..0 RO/RWC: TBD by Action Error Injection Job-Manager Not yet implemented Address: 0x000E800 63..17 RO: Reserved 16 RS: Force Job Ctrl State Machine Hang 15..0 RO: Reserved Error Injection MMIO Not yet implemented Address: 0x000E808 63..17 RO: Reserved 16 RS: Inject MMIO Read Response Data Parity error into PSL interface 15..1 RO: Reserved 0 RS: Inject MMIO Write Data Parity error Error Injection DMA Not yet implemented Address: 0x000E810 63..22 RO: Reserved 21 RS: Inject error into DMA write path (flip data bit) 20 RS: Inject error into DMA read path (flip data bit) 19 RS: Inject parity error into command on AH Command Bus to PSL 18 RS: Inject parity error into effective address on AH Command Bus to PSL 17 RS: Inject parity error into response on AH Buffer Interface to PSL 16 RS: Inject parity error into response tag on AH Command Bus to PSL 15..0 RO: Reserved Slave PSA for Context n Implementation Version Register (IVR) Address: 0x0000000 + (s+n) * 0x0010000 63..40 RO: SNAP Release 63..56: Major release number 55..48: Intermediate release number 47..40: Minor release number 39..32 RO: Distance of commit to SNAP release 31..0 RO: First eight digits of SHA ID for commit POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8 Build Date Register (BDR) Address: 0x0000008 + (s+n) * 0x0010000 63..48 RO: Reserved 47..0 RO: BCD coded build date and time 47..32: YYYY (year) 31..24: mm (month) 23..16: dd (day of month) 15..08: HH (hour) 07..00: MM (minute) POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527 SNAP Command Register (SCR) (commands \\<Reset>, \\<Abort> are not yet implemented) Address: 0x0000010 + (s+n) * 0x0010000 63..48 RO: Argument 47..8 RO: Reserved 7..0 RO: Command Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register Argument bits 63..52: Don't care Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone) Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone) Argument: Don't care 0x00 NOP SNAP Status Register (SSR) Address: 0x0000018 + (s+n) * 0x0010000 63..9 RO: Reserved 8 RO: Exploration Done This means that the ATRi setup is complete and the values are valid 7..4 RO: Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO: Maximum Action ID POR value: 0x000000000000000a with a = maximum action ID for this card build SNAP Reset Control Register (SRC) Address: 0x0000028 + (s+n) * 0x0010000 63..5 RO: Reserved 4 RO: Reset PCIe core and NVMe drives '1' : keep RESET active 3..0 RO: Reset NVMe drives via the four M2_PERST_N pins Bit i='1' : pull down M2_PERST_N(i) POR value: 0x0000000000000000 SNAP Capability Register (SCaR) Address: 0x0000030 + (s+n) * 0x0010000 63..40 RO: Reserved 39..36 RO: Minimum size for DMA transfers to/from Host Value t means that minimum transfer size is 2^t B 35..32 RO: Data alignment for DMA transfers to/from Host Value a means that transfers need to be 2^a B aligned 31..16 RO: Size of attached on-card SDRAM in MB 15..9 RO: Reserved 8 RO: NVMe enabled 7..0 RO: Card type: 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3 Freerunning Timer (FRT) Address: 0x0000080 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles since reset (afu open) This counter increments with the 250MHz PSL clock. Job Timeout Register (JTR) Not yet implemented (required ??? per context ???) Address: 0x0000088 + (s+n) * 0x0010000 63 RW: Enable Job Timeout checking (1=enabled) 62..32 RO: Reserved 31..0 RW: Job Timeout value (this value decrements with the 250MHz PSL clock) POR value: 0x80000000_0ABA9500 timeout enabled with 1s Action Active Counter (AAC) Not yet implemented (required ???) Address: 0x0000090 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles while an action is active This counter increments with the 250MHz PSL clock. Context Execution Counter (CEC) Not yet implemented (required ???) Address: 0x0000098 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles while a job gets executed for this context This counter increments with the 250MHz PSL clock. Context ID Register (CIR) Address: 0x00000A0 + (s+n) * 0x0010000 63 RO: Set to '0' for slave register 62..9 RO: Reserved 8..0 RO: My context id (9 bits corresponding to context IDs in the range 0..511) Action Type Register i (ATRi) (0 <= i < 16) Address: 0x0000100 + (s+n) * 0x0010000 + i * 0x0000008 63..36 RO: Reserved 35..32 RO: Internal Short Action Type 31..0 RO: Action type for action i (all zero if no Action i is implemented) POR value: 0x00000000_00000000 LIBSNAP needs to specify the values based on the result of an exploration phase Action Counter Register i (ACRi) (0 <= i < 16) Address: 0x0000180 + (s+n) * 0x0010000 + i * 0x0000008 63..0 RO: Cumulative counter counting the number of clock cycles while action i is active This counter increments with the 250MHz PSL clock. POR value: 0x00000000_00000000 Context specific registers Context Configuration Register (CCR) ** This register must not be written while the job queue is active (CSR bits 4 or 5 are set) ** ** A valid write operation into this register resets the corresponding Job Queue Work Timer ** Address: 0x0001000 + (s+n) * 0x0010000 63..48 RW: First expected job queue sequence number 47..32 RO: Reserved 31..24 RW: First job queue index to execute. Must be <= Max job queue index 23..16 RW: Max job queue index 15..12 RW: Requested Short Action Type 11..0 RW: Job handling attributes 11..3 Reserved for future use 2 Enable SNAP interrupt for action assignment 1 Enable SNAP interrupt for job completion (action enters idle mode) 0 Execution mode: 0=Job Queue Mode 1=Direct Action Access Mode POR value: 0x00000000_00000000 Context Status Register (CSR) Address: 0x0001008 + (s+n) * 0x0010000 63..48 RO: Current job sequence number *** This is the next sequence number to be executed when no job is being executed 47..32 RO: Last job sequence number to be executed 31..24 RO: Current job queue index 23..16 RO: Reserved 15..12 RO: Short Action Type assigned to this context (if bit 7 = 1) 11..8 RO: ID of attached action (if bit 6 = 1) 7 RO: Short Action Type for this context is assigned 6 RO: This context is attached to an action 5..2 RO: Reserved 1 RO: Currently executing job ??? (redundant with bit 6?) 0 RO: Context Active Job Command Register (JCR) Address: 0x0001010 + (s+n) * 0x0010000 63..48 RW: Argument 47..4 RO: Reserved 3..0 RW: Command Legal commands are: 0x4 Abort: Stop all job activities for this context immediately Argument: Don't care 0x2 Stop: Detach action from context - immediately in direct access mode - after completion of current job in job mode Argument: Don't care 0x1 Start: Attach action to context and execute jobs in job queue if in job mode Argument: <Last sequence number to be executed> must be set) 0x0 NOP POR value: 0x00000000_00000000 Attached Action Type Register (AAT) Not yet implemented (required ???) Address: 0x0001018 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Attached action type (all zero if no action is attached) Job Request Queue Start Pointer Register (JReqQR) Not yet implemented Address: 0x0001020 + (s+n) * 0x0010000 63..0 Pointer to start of job queue for this context in system memory 63..8 RW 7..0 RO: Always 0 POR value: 0x00000000_00000000 Job Response Queue Start Pointer Register (JRspQR) Not yet implemented Address: 0x0001028 + (s+n) * 0x0010000 63..0 Pointer to start of job queue for this context in system memory 63..8 RW 7..0 RO: Always 0 POR value: 0x00000000_00000000 Context Error Register (CER) Not yet implemented Address: 0x0001030 + (s+n) * 0x0010000 63..24 RO: Reserved 23..8 RWC: Non-fatal errors: 23..20: DMA Response Error Code (see DMA Error Address Register for DMA address triggering the error) 0=DONE 1=AERROR 3=DERROR 4=NLOCK 5=NRES 6=FLUSHED 7=FAULT 8=FAILED A=PAGED B=CONTEXT F=ILLEGAL_RSP 19: DMA Response Error Source 1=Interrupt or Restart 0=DMA Read or DMA Write 18: Received illegal command in DDCB Queue Command Register 17: Invalid Sequence number in DDCB (queue will be stopped) 16: Write attempt to DDCB Queue Start Pointer register while Queue active 15: Write attempt to DDCB Queue Configuration register while Queue active 14: Write attempt to DDCB Queue Configuration register with first DDCB index > max DDCB index 13: MMIO Cfg Write access (illegal for non cfg space area) 12: MMIO Write access to master register via slave address 11: Illegal MMIO write address 10: Illegal MMIO write alignment 9: Illegal MMIO read address 8: Illegal MMIO read alignment 7..0 RO: Reserved Context DMA Error Address Register (CDEAR) Not yet implemented (required ???) Address: 0x0001038 + (s+n) * 0x0010000 63..0 RO: DMA address that caused the error Context Work Timer (CWT) Not yet implemented (required ???) Address: 0x0001080 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles during job execution for this context (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset) This counter increments with the 250MHz PSL clock. Context Attach Status Vector (CASV) Not yet implemented (required ???) Address: 0x00C000 + (s+n) * 0x0010000 + m * 0x0000008 (m = 0,..,15) 63..32 RO: Reserved 31..0 RO: Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31). SNAP Debug Register (SDR) Address: 0x000D000 + (s+n) * 0x0010000 63..1 RO: Reserved 0 RW: Enable PSL parity checking via AFU Control Interface to PSL '1': Parity checking is enabled '0': Parity checking is disabled (default value) POR value: 0x00000000_00000000 SNAP NVMe Register (SNR) Address: 0x000D008 + (s+n) * 0x0010000 63..0 RO: Reserved for NVMe usage POR value: 0x00000000_00000000 Job-Manager FIRs Not yet implemented Address: 0x000E000 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: FIR bits TBD MMIO FIRs Not yet implemented Address: 0x000E008 + (s+n) * 0x0010000 63..32 RO: Reserved 31..1 RO: Reserved (FIR bits TBD) 0 RO: Parity errror DMA FIRs Not yet implemented Address: 0x000E010 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Reserved (FIR bits TBD) Attached Action FIRs Not yet implemented Address: 0x000E018 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Reserved (FIR bits TBD) Action i FIRs Not yet implemented Address: 0x000E100 + (s+n) * 0x0010000 + i * 0x0000008 63..0 RO: TBD by Action Error Injection Job-Manager Not yet implemented Address: 0x000E800 + (s+n) * 0x0010000 63..17 RO: Reserved 16 RO: Force Job Ctrl State Machine Hang 15..0 RO: Reserved Error Injection MMIO Not yet implemented Address: 0x000E808 + (s+n) * 0x0010000 63..17 RO: Reserved 16 RO: Inject MMIO Read Response Data Parity error into PSL interface 15..1 RO: Reserved 0 RO: Inject MMIO Write Data Parity error Error Injection DMA Not yet implemented Address: 0x000E810 + (s+n) * 0x0010000 63..22 RO: Reserved 21 RO: Inject error into DMA write path (flip data bit) 20 RO: Inject error into DMA read path (flip data bit) 19 RO: Inject parity error into command on AH Command Bus to PSL 18 RO: Inject parity error into effective address on AH Command Bus to PSL 17 RO: Inject parity error into response on AH Buffer Interface to PSL 16 RO: Inject parity error into response tag on AH Command Bus to PSL 15..0 RO: Reserved Error Injection Attached Action Not yet implemented Address: 0x000E818 + (s+n) * 0x0010000 63..0 RO: TBD by Action MMIO-Map Action Space Each action has a 4KB MMIO space which can be accessed from a master context or from a slave context using the address ranges as described in the respective MMIO-Map above. The following MMIO registers have dedicated meanings within the SNAP framework. When the Action gets created using Xilinx HLS the registers marked as \"Reserved\" are required for HLS control information. Otherwise, they may be used for any purpose. Offset Description Access ======= ==================== ======= 0x000 | | ... | Action control | RW 0x00C | | ==================== 0x010 | Action Type | RO ==================== 0x014 | Action Version | RO ==================== 0x018 | Reserved | 0x01C | | ==================== 0x020 | Context ID | WO ==================== 0x024 | Reserved | ==================== 0x028 | | ... Unused 0x0FC | | ==================== 0x100 | Request Queue | ... | element | WO 0x178 | | ==================== 0x17C | Reserved | ==================== 0x180 | Response Queue | ... | element | RO 0x1F8 | | ==================== 0x1FC | Reserved | ==================== 0x200 | | ... Unused 0xFFC | | ==================== Action Register Layout Action Control Register Address: 0x000 31..8 RO: Reserved 7 RW: auto restart 6..4 RO: Reserved 3 RO: Ready 2 RO: Idle 1 RC: Done 0 RW: Start Interrupt Enable Register Address: 0x004 31..1 RO: Reserved 0 RW: Enable Interrupt Action Type Register Address: 0x010 31..0 RO: Unique four byte number specifying the type (the implemented functionality) of this action Action Version Register Address: 0x014 31..0 RO: Four byte number specifying the version of this action. Context ID Register Address: 0x020 31..8 RO: Reserved 7..0 RW: Context ID to be passed with DMA and Interrupt commands to the host. PSL Registers Taken from PSL spec PSL Slice Error Register (PSL_SErr_An) n = 0,1,2,3 Address: BAR2 + 0x010028 + n * 0x000100 63 RWC: AFU MMIO Timeout (afuto). Enabled Accelerator did not respond to MMIO operation (mmio_afuto_err). The hang pulse frequency must be configured in PSL_DSNDCTL[mmiohp] for the hang to be detected. A read operation returns Zeroes. The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 62 RWC: MMIO targeted Accelerator that was not enabled (afudis). (mmio_dis_err) A write operation is ignored. A read operation returns data of 'DEADB00FDEADB00F' when PSL_RXCTL_An[deadb00f]=1 or all ones when PSL_RXCTL_An[deadb00f]=0.The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 61 RWC: AFU CTAG Overflow (afuov). Accelerator issued more than 64 outstanding CMD requests (rx_jm_sf_error(0)). Request is ignored and there are no ill effects to PSL. This bit is cleared by writing a '1'. 60 RWC: Bad Interrupt Source (badsrc). In AFU Directed Mode only, Accelerator issued an interrupt request with an unsupported interrupt source. The interrupt source did not fit into any enabled and defined ranges in the PSL_IVTE_LIMIT_An. The request received a 'failed' response so this notification is redundant and should be masked. In other modes this bit is reserved. This bit is cleared by writing a '1'. 59 RWC: Bad Context Handle (badctx). In AFU_Directed Mode only, the accelerator issued a request using a bad context handle. (The retrieved SWSTATE is not valid , PSL_SPAP[V]=0). The request received a context response so this notification is redundant and should be masked. In other modes this bit is reserved. 58 RWC: LLCMD to Disabled AFU (llcmddis). in AFU Directed Mode, SW updated the PSl_LLCMD_An register when the AFU was not enabled. This may not be an error and should be MASKED if expected. The LLCMD is forwarded to the translation logic which will indicate an 'error' completion status in the Software command/status field in the scheduled process area.In other modes, this bit is reserved. This bit is cleared by writing a '1'. 57 RWC: LLCMD Timeout to AFU (llcmdto). In AFU Directed Mode only, the AFU did not assert ah_jcack on the afu control interface in response to a LLCMD within the timeout period. The hang pulse frequency must be configured in PSL_RXCTL_An[afuhp] for the hang to be detected. The LLCMD is forwarded to the Translation Logic which will indicate an 'error' completion status in the Software command/status field in the scheduled process area. This notification is redundant and should be masked. In other modes, this bit is reserved. This error should be MASKED in production. This bit is clerared by writing a '1'. 56 RWC: AFU MMIO Parity Error (afupar). A MMIO read of an AFU register contained bad parity. The read operation returns data of DEADB00FDEADB00F when PSL_RXCTL_An[deadb00f]=1 or all ones when PSL_RXCTL_An[deadb00f]=0. The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 55 RWC: AFU Duplicate CTAG Error (afudup). The accelerator issue a CMD with a CTAG that is already in use. The request is accepted but the PSL queues have been corrupted and requests may be lost. The PSL requires a reload and may start setting FIR1/2 bits. 64..48 RWC: Reserved for Implementation Specific Errors 47..34 RWC: Reserved for CAIA Defined Errors 33 RWC: AFU Error (AE). AFU asserted JDONE with JERROR in AFU Directed Mode. JERROR information is captured in the AFU_ERROR_An register. This error is asserted in the DSISR_An when in other modes. 32 RWC: (HC). Not GA1. PSL_CtxTime[Warn_Hypervisor] timer interval expires 31 RWC: (afuto_mask). Set by system software to disable reporting of afuto interrupt. 30 RWC: (afudis_mask). Set by system software to disable reporting of afudis interrupt. 29 RWC: (afuov_mask). Set by system software to disable reporting of afuov interrupt. 28 RWC: (badsrc_mask). Set by system software to disable reporting of badsrc interrupt. 27 RWC: (badctx_mask). Set by system software to disable reporting of badctx interrupt. 26 RWC: (llcmddis_mask). Set by system software to disable reporting of llcmddis interrupt. 25 RWC: (llcmdto_mask). Set by system software to disable reporting of llcmdto interrupt. 24 RWC: (afupar_mask). Set by system software to disable reporting of afupar interrupt. 23 RWC: (afudup_mask). Set by system software to disable reporting of afudup interrupt. 22..16 RWC: Reserved for Implementation Specific Error Masks 15..0 RWC: (errivte_slice). IVTE value used to report this interrupt PSL AFU Debug Register (PSL_AFU_DEBUG_An) n = 0,1,2,3 Address: BAR2 + 0x0100C8 + n * 0x000100 63..58 RO: Reserved 57..34 RO: AFU MMIO Adr on Error (mmio_addr). This register contains the address of the 1st MMIO sent to the AFU that caused an (unmasked) afu mmio error to be reported in the PSl_SERR_An if afuto, afupar, or afudis. 33..32 RO: Reserved 31..16 RO: Context Handle on Error (handle) - Proposed (Not implemented yet) -This register contains the Context handle of the 1st error set in the PSL_SERR_An if badctx, llcmdto, llcmddis, or badsrc 15..11 RO: Reserved 10..0 RO: Interrupt Source on Error (int_src) - Proposed (Not implemented yet) - This register contains the Interrupt source of the 1st error set in the PSL_SERR_An if badsrc.","title":"SNAP Registers"},{"location":"deep-dive/registers/#snap-registers","text":"Warning OpenCAPI doesn't have the concept of Master-context and Slave-context. The register definitions may have a big change.","title":"SNAP Registers"},{"location":"deep-dive/registers/#mmio-map-master-space","text":"While the master context has access to the whole MMIO space the first 32MB of the MMIO space are accessible by the master exclusively (with s = 512 this is corresponding to the address range below s * 0x0010000). The Framework Control and Status registers (aka Master PSA registers) are 8B registers. All the other registers are 4B wide. Address ========= ======================================== 0x0000000 | | | Master Context | ... | Framework Control & Status | | (64KB) | 0x000FFF8 | | ======================================== 0x0010000 | | ... | Action 0x0 (4KB) | 0x0010FFC | | ==================== 0x0011000 | | ... | Action 0x1 (4KB) | 0x0011FFC | | ==================== 0x0012000 | | ... | Action 0x2 (4KB) | 0x0012FFC | | ==================== ... ==================== 0x001F000 | | ... | Action 0xF (4KB) | 0x001FFFC | | ==================== 0x0020000 | | | NVME | ... | Config & Admin | | (128KB) | 0x003FFFC | | ====================","title":"MMIO-MAP - Master Space"},{"location":"deep-dive/registers/#mmio-map-slave-context","text":"Each slave context has access to its own 64KB MMIO space only via the address offset. PSL is adding the base address which is (s+n)*0x0010000 where s is 512 and n is the context id. The MMIO space of the action attached to the context is mapped into the last 4KB of the slave context space. The Framework Control and Status registers (aka Slave PSA) are 8B registers. The action's registers are 4B wide. The master context has access to each slave context space. Address map for context n (0 <= n < 512), and with s = 512: Base Offset ============================= ======================================== (s+n)*0x0010000 + 0x0000000 | | | Slave Context n | ... | Framework Control & Status | | (60KB) | (s+n)*0x0010000 + 0x000EFF8 | | ======================================== (s+n)*0x0010000 + 0x000F000 | | ... | Action (4KB) | (s+n)*0x0010000 + 0x000FFFC | | ====================","title":"MMIO-MAP Slave Context"},{"location":"deep-dive/registers/#snap-framework-register-specifications","text":"RW = Read/Write RO = Read only - Reserved bits return 0 unless specified otherwise RC = Read only with clear on read RWC = Read/WriteClear (Write clears (=>0) the bits for each bit=1 in the write value) RWS = Read/WriteSet (Write sets (=>1) the bits for each bit=1 in the write value) n = Context Handle (aka. Process ID; 0 <= n < number of processes)","title":"SNAP Framework Register Specifications"},{"location":"deep-dive/registers/#master-psa","text":"","title":"Master PSA"},{"location":"deep-dive/registers/#implementation-version-register-ivr","text":"Address: 0x0000000 63..40 RO: SNAP Release 63..56: Major release number 55..48: Intermediate release number 47..40: Minor release number 39..32 RO: Distance of commit to SNAP release 31..0 RO: First eight digits of SHA ID for commit POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8","title":"Implementation Version Register (IVR)"},{"location":"deep-dive/registers/#build-date-register-bdr","text":"Address: 0x0000008 63..48 RO: Reserved 47..0 RO: BCD coded build date and time 47..32: YYYY (year) 31..24: mm (month) 23..16: dd (day of month) 15..08: HH (hour) 07..00: MM (minute) POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527","title":"Build Date Register (BDR)"},{"location":"deep-dive/registers/#snap-command-register-scr","text":"(commands \\<Reset>, \\<Abort> are not yet implemented) Address: 0x0000010 63..48 RW: Argument 47..8 RO: Reserved 7..0 RW: Command Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register Argument bits 63..52: Don't care Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone) Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone) Argument: Don't care 0x00 NOP","title":"SNAP Command Register (SCR)"},{"location":"deep-dive/registers/#snap-status-register-ssr","text":"Address: 0x0000018 63..9 RO: Reserved 8 RO: Exploration Done This means that the ATRi setup is complete and the values are valid 7..4 RO: Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO: Maximum Action ID POR value: 0x000000000000000a with a = maximum action ID for this card build","title":"SNAP Status Register (SSR)"},{"location":"deep-dive/registers/#snap-lock-register-slr","text":"Address: 0x0000020 63..1 RO: Reserved 0 RW: Lock (Set on Read) POR value: 0x0000000000000000","title":"SNAP Lock Register (SLR)"},{"location":"deep-dive/registers/#snap-reset-control-register-src","text":"Address: 0x0000028 63..5 RO: Reserved 4 RW: Reset PCIe core and NVMe drives '1' : keep RESET active 3..0 RW: Reset NVMe drives via the four M2_PERST_N pins Bit i='1' : pull down M2_PERST_N(i) POR value: 0x0000000000000000","title":"SNAP Reset Control Register (SRC)"},{"location":"deep-dive/registers/#snap-capability-register-scar","text":"Address: 0x0000030 63..40 RO: Reserved 39..36 RO: Minimum size for DMA transfers to/from Host Value t means that minimum transfer size is 2^t B 35..32 RO: Data alignment for DMA transfers to/from Host Value a means that transfers need to be 2^a B aligned 31..16 RO: Size of attached on-card SDRAM in MB 15..9 RO: Reserved 8 RO: NVMe enabled 7..0 RO: Card type: 0x13 : S241 0x12 : FX609 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3","title":"SNAP Capability Register (SCaR)"},{"location":"deep-dive/registers/#freerunning-timer-frt","text":"Address: 0x0000080 63..0 RO: Counter counting the number of clock cycles since reset (afu open) This counter increments with the 250MHz PSL clock.","title":"Freerunning Timer (FRT)"},{"location":"deep-dive/registers/#job-timeout-register-jtr","text":"","title":"Job Timeout Register (JTR)"},{"location":"deep-dive/registers/#not-yet-implemented-required-for-all-contexts","text":"Address: 0x0000088 63 RW: Enable Job Timeout checking (1=enabled) 62..32 RO: Reserved 31..0 RW: Job Timeout value (this value decrements with the 250MHz PSL clock) POR value: 0x80000000_0ABA9500 timeout enabled with 1s","title":"Not yet implemented (required ??? for all contexts ???)"},{"location":"deep-dive/registers/#action-active-counter-aac","text":"","title":"Action Active Counter (AAC)"},{"location":"deep-dive/registers/#not-yet-implemented-required","text":"Address: 0x0000090 63..0 RO: Counter counting the number of clock cycles while an action is active This counter increments with the 250MHz PSL clock.","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-execution-counter-cec","text":"","title":"Context Execution Counter (CEC)"},{"location":"deep-dive/registers/#not-yet-implemented-required_1","text":"Address: 0x0000098 63..0 RO: Counter counting the number of clock cycles while a job gets executed on the card This counter increments with the 250MHz PSL clock.","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-id-register-cir","text":"Address: 0x00000A0 63 RO: Set to '1' for master register 62..0 RO: Reserved (no context ID for master)","title":"Context ID Register (CIR)"},{"location":"deep-dive/registers/#action-type-register-i-atri","text":"(0 <= i < 16) Address: 0x0000100 + i * 0x0000008 63..36 RO: Reserved 35..32 RW: Internal Short Action Type 31..0 RW: Action type for action i (all zero if no Action i is implemented) POR value: 0x00000000_00000000 LIBSNAP needs to specify the values based on the result of an exploration phase","title":"Action Type Register i (ATRi)"},{"location":"deep-dive/registers/#action-counter-register-i-acri","text":"(0 <= i < 16) Address: 0x0000180 + i * 0x0000008 63..0 RW: Cumulative counter counting the number of clock cycles while action i is active This counter increments with the 250MHz PSL clock. It can be reset or preset to any value by the master. POR value: 0x00000000_00000000","title":"Action Counter Register i (ACRi)"},{"location":"deep-dive/registers/#context-attach-status-vector-casv","text":"","title":"Context Attach Status Vector (CASV)"},{"location":"deep-dive/registers/#not-yet-implemented-required_2","text":"Address: 0x00C000 + m * 0x0000008 (m = 0,..,15) 63..32 RO: Reserved 31..0 RO: Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31).","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#snap-debug-register-sdr","text":"Address: 0x000D000 63..1 RO: Reserved 0 RW: Enable PSL parity checking via AFU Control Interface to PSL '1': Parity checking is enabled '0': Parity checking is disabled (default value) POR value: 0x00000000_00000000","title":"SNAP Debug Register (SDR)"},{"location":"deep-dive/registers/#snap-nvme-register-snr","text":"Address: 0x000D008 63..0 RW: Reserved for NVMe usage POR value: 0x00000000_00000000","title":"SNAP NVMe Register (SNR)"},{"location":"deep-dive/registers/#job-manager-firs","text":"","title":"Job-Manager FIRs"},{"location":"deep-dive/registers/#not-yet-implemented","text":"Address: 0x000E000 63..6 RO: Reserved 5 RWC: EA Parity Error 4 RWC: COM Parity Error 3 RWC: DDCB Read FSM Error 2 RWC: DDCB Queue Control FSM Error 1 RWC: Job Control FSM Error 0 RWC: Context Control FSM Error","title":"Not yet implemented"},{"location":"deep-dive/registers/#mmio-firs","text":"","title":"MMIO FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_1","text":"Address: 0x000E008 63..10 RO: Reserved 9 RWC: MMIO DDCBQ Work-Timer RAM Parity Error 8 RWC: MMIO DDCBQ DMA-Error RAM Parity Error 7 RWC: MMIO DDCBQ Last Sequence Number RAM Parity Error 6 RWC: MMIO DDCBQ Index and Sequence Number RAM Parity Error 5 RWC: MMIO DDCBQ Non-Fatal-Error RAM Parity Error 4 RWC: MMIO DDCBQ Status RAM Parity Error 3 RWC: MMIO DDCBQ Config RAM Parity Error 2 RWC: MMIO DDCBQ Start Pointer RAM Parity Error 1 RWC: MMIO Write Address Parity Error 0 RWC: MMIO Write Data Parity Error","title":"Not yet implemented"},{"location":"deep-dive/registers/#dma-firs","text":"","title":"DMA FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_2","text":"Address: 0x000E010 63..10 RO: Reserved 9 RWC: DMA Aligner Write FSM Error 8 RWC: DMA Aligner Read FSM Error 7 RO: Reserved 6 RWC: HA Buffer Interface Write Data Error 5 RWC: HA Buffer Interface Write Tag Error 4 RWC: HA Buffer Interface Read TAG Error 3 RWC: HA Response Interface Tag Error 2 RWC: DMA Write Control FSM Error 1 RWC: DMA Read Control FSM Error 0 RWC: AH Command FSM Error","title":"Not yet implemented"},{"location":"deep-dive/registers/#action-i-firs","text":"","title":"Action i FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_3","text":"Address: 0x000E100 + i * 0x0000008 63..0 RO/RWC: TBD by Action","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-job-manager","text":"","title":"Error Injection Job-Manager"},{"location":"deep-dive/registers/#not-yet-implemented_4","text":"Address: 0x000E800 63..17 RO: Reserved 16 RS: Force Job Ctrl State Machine Hang 15..0 RO: Reserved","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-mmio","text":"","title":"Error Injection MMIO"},{"location":"deep-dive/registers/#not-yet-implemented_5","text":"Address: 0x000E808 63..17 RO: Reserved 16 RS: Inject MMIO Read Response Data Parity error into PSL interface 15..1 RO: Reserved 0 RS: Inject MMIO Write Data Parity error","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-dma","text":"","title":"Error Injection DMA"},{"location":"deep-dive/registers/#not-yet-implemented_6","text":"Address: 0x000E810 63..22 RO: Reserved 21 RS: Inject error into DMA write path (flip data bit) 20 RS: Inject error into DMA read path (flip data bit) 19 RS: Inject parity error into command on AH Command Bus to PSL 18 RS: Inject parity error into effective address on AH Command Bus to PSL 17 RS: Inject parity error into response on AH Buffer Interface to PSL 16 RS: Inject parity error into response tag on AH Command Bus to PSL 15..0 RO: Reserved","title":"Not yet implemented"},{"location":"deep-dive/registers/#slave-psa-for-context-n","text":"","title":"Slave PSA for Context n"},{"location":"deep-dive/registers/#implementation-version-register-ivr_1","text":"Address: 0x0000000 + (s+n) * 0x0010000 63..40 RO: SNAP Release 63..56: Major release number 55..48: Intermediate release number 47..40: Minor release number 39..32 RO: Distance of commit to SNAP release 31..0 RO: First eight digits of SHA ID for commit POR value depends on source for the build. Example for build based on commit with SHA ID eb43f4d80334d6a127af150345fed12dc5f45b7c and with distance 13 to SNAP Release v1.25.4: 0x0119040D_EB43F4D8","title":"Implementation Version Register (IVR)"},{"location":"deep-dive/registers/#build-date-register-bdr_1","text":"Address: 0x0000008 + (s+n) * 0x0010000 63..48 RO: Reserved 47..0 RO: BCD coded build date and time 47..32: YYYY (year) 31..24: mm (month) 23..16: dd (day of month) 15..08: HH (hour) 07..00: MM (minute) POR value depends on build date and time. Example for build on January 12th, 2017 at 15:27: 0x00002017_01121527","title":"Build Date Register (BDR)"},{"location":"deep-dive/registers/#snap-command-register-scr_1","text":"(commands \\<Reset>, \\<Abort> are not yet implemented) Address: 0x0000010 + (s+n) * 0x0010000 63..48 RO: Argument 47..8 RO: Reserved 7..0 RO: Command Legal commands are: 0x10 Exploration Done: Set Exploration Done bit in SNAP status register Argument bits 63..52: Don't care Argument bits 51..48: Maximum Short Action Type 0x08 Reset: Reset the complete SNAP framework including all actions immediately Argument: Don't care 0x04 Abort: Abort current jobs and set accelerator to finished immediately (asserting aXh_jdone) Argument: Don't care 0x02 Stop: Finish current jobs, then set accelerator to finished (asserting aXh_jdone) Argument: Don't care 0x00 NOP","title":"SNAP Command Register (SCR)"},{"location":"deep-dive/registers/#snap-status-register-ssr_1","text":"Address: 0x0000018 + (s+n) * 0x0010000 63..9 RO: Reserved 8 RO: Exploration Done This means that the ATRi setup is complete and the values are valid 7..4 RO: Maximum Short Action Type (number of Short Action Types - 1) 3..0 RO: Maximum Action ID POR value: 0x000000000000000a with a = maximum action ID for this card build","title":"SNAP Status Register (SSR)"},{"location":"deep-dive/registers/#snap-reset-control-register-src_1","text":"Address: 0x0000028 + (s+n) * 0x0010000 63..5 RO: Reserved 4 RO: Reset PCIe core and NVMe drives '1' : keep RESET active 3..0 RO: Reset NVMe drives via the four M2_PERST_N pins Bit i='1' : pull down M2_PERST_N(i) POR value: 0x0000000000000000","title":"SNAP Reset Control Register (SRC)"},{"location":"deep-dive/registers/#snap-capability-register-scar_1","text":"Address: 0x0000030 + (s+n) * 0x0010000 63..40 RO: Reserved 39..36 RO: Minimum size for DMA transfers to/from Host Value t means that minimum transfer size is 2^t B 35..32 RO: Data alignment for DMA transfers to/from Host Value a means that transfers need to be 2^a B aligned 31..16 RO: Size of attached on-card SDRAM in MB 15..9 RO: Reserved 8 RO: NVMe enabled 7..0 RO: Card type: 0x11 : RCXVUP 0x10 : N250SP 0x03 : AD8K5 0x02 : S121B 0x01 : N250S 0x00 : ADKU3","title":"SNAP Capability Register (SCaR)"},{"location":"deep-dive/registers/#freerunning-timer-frt_1","text":"Address: 0x0000080 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles since reset (afu open) This counter increments with the 250MHz PSL clock.","title":"Freerunning Timer (FRT)"},{"location":"deep-dive/registers/#job-timeout-register-jtr_1","text":"","title":"Job Timeout Register (JTR)"},{"location":"deep-dive/registers/#not-yet-implemented-required-per-context","text":"Address: 0x0000088 + (s+n) * 0x0010000 63 RW: Enable Job Timeout checking (1=enabled) 62..32 RO: Reserved 31..0 RW: Job Timeout value (this value decrements with the 250MHz PSL clock) POR value: 0x80000000_0ABA9500 timeout enabled with 1s","title":"Not yet implemented (required ??? per context ???)"},{"location":"deep-dive/registers/#action-active-counter-aac_1","text":"","title":"Action Active Counter (AAC)"},{"location":"deep-dive/registers/#not-yet-implemented-required_3","text":"Address: 0x0000090 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles while an action is active This counter increments with the 250MHz PSL clock.","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-execution-counter-cec_1","text":"","title":"Context Execution Counter (CEC)"},{"location":"deep-dive/registers/#not-yet-implemented-required_4","text":"Address: 0x0000098 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles while a job gets executed for this context This counter increments with the 250MHz PSL clock.","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-id-register-cir_1","text":"Address: 0x00000A0 + (s+n) * 0x0010000 63 RO: Set to '0' for slave register 62..9 RO: Reserved 8..0 RO: My context id (9 bits corresponding to context IDs in the range 0..511)","title":"Context ID Register (CIR)"},{"location":"deep-dive/registers/#action-type-register-i-atri_1","text":"(0 <= i < 16) Address: 0x0000100 + (s+n) * 0x0010000 + i * 0x0000008 63..36 RO: Reserved 35..32 RO: Internal Short Action Type 31..0 RO: Action type for action i (all zero if no Action i is implemented) POR value: 0x00000000_00000000 LIBSNAP needs to specify the values based on the result of an exploration phase","title":"Action Type Register i (ATRi)"},{"location":"deep-dive/registers/#action-counter-register-i-acri_1","text":"(0 <= i < 16) Address: 0x0000180 + (s+n) * 0x0010000 + i * 0x0000008 63..0 RO: Cumulative counter counting the number of clock cycles while action i is active This counter increments with the 250MHz PSL clock. POR value: 0x00000000_00000000","title":"Action Counter Register i (ACRi)"},{"location":"deep-dive/registers/#context-specific-registers","text":"","title":"Context specific registers"},{"location":"deep-dive/registers/#context-configuration-register-ccr","text":"** This register must not be written while the job queue is active (CSR bits 4 or 5 are set) ** ** A valid write operation into this register resets the corresponding Job Queue Work Timer ** Address: 0x0001000 + (s+n) * 0x0010000 63..48 RW: First expected job queue sequence number 47..32 RO: Reserved 31..24 RW: First job queue index to execute. Must be <= Max job queue index 23..16 RW: Max job queue index 15..12 RW: Requested Short Action Type 11..0 RW: Job handling attributes 11..3 Reserved for future use 2 Enable SNAP interrupt for action assignment 1 Enable SNAP interrupt for job completion (action enters idle mode) 0 Execution mode: 0=Job Queue Mode 1=Direct Action Access Mode POR value: 0x00000000_00000000","title":"Context Configuration Register (CCR)"},{"location":"deep-dive/registers/#context-status-register-csr","text":"Address: 0x0001008 + (s+n) * 0x0010000 63..48 RO: Current job sequence number *** This is the next sequence number to be executed when no job is being executed 47..32 RO: Last job sequence number to be executed 31..24 RO: Current job queue index 23..16 RO: Reserved 15..12 RO: Short Action Type assigned to this context (if bit 7 = 1) 11..8 RO: ID of attached action (if bit 6 = 1) 7 RO: Short Action Type for this context is assigned 6 RO: This context is attached to an action 5..2 RO: Reserved 1 RO: Currently executing job ??? (redundant with bit 6?) 0 RO: Context Active","title":"Context Status Register (CSR)"},{"location":"deep-dive/registers/#job-command-register-jcr","text":"Address: 0x0001010 + (s+n) * 0x0010000 63..48 RW: Argument 47..4 RO: Reserved 3..0 RW: Command Legal commands are: 0x4 Abort: Stop all job activities for this context immediately Argument: Don't care 0x2 Stop: Detach action from context - immediately in direct access mode - after completion of current job in job mode Argument: Don't care 0x1 Start: Attach action to context and execute jobs in job queue if in job mode Argument: <Last sequence number to be executed> must be set) 0x0 NOP POR value: 0x00000000_00000000","title":"Job Command Register (JCR)"},{"location":"deep-dive/registers/#attached-action-type-register-aat","text":"","title":"Attached Action Type Register (AAT)"},{"location":"deep-dive/registers/#not-yet-implemented-required_5","text":"Address: 0x0001018 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Attached action type (all zero if no action is attached)","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#job-request-queue-start-pointer-register-jreqqr","text":"","title":"Job Request Queue Start Pointer Register (JReqQR)"},{"location":"deep-dive/registers/#not-yet-implemented_7","text":"Address: 0x0001020 + (s+n) * 0x0010000 63..0 Pointer to start of job queue for this context in system memory 63..8 RW 7..0 RO: Always 0 POR value: 0x00000000_00000000","title":"Not yet implemented"},{"location":"deep-dive/registers/#job-response-queue-start-pointer-register-jrspqr","text":"","title":"Job Response Queue Start Pointer Register (JRspQR)"},{"location":"deep-dive/registers/#not-yet-implemented_8","text":"Address: 0x0001028 + (s+n) * 0x0010000 63..0 Pointer to start of job queue for this context in system memory 63..8 RW 7..0 RO: Always 0 POR value: 0x00000000_00000000","title":"Not yet implemented"},{"location":"deep-dive/registers/#context-error-register-cer","text":"","title":"Context Error Register (CER)"},{"location":"deep-dive/registers/#not-yet-implemented_9","text":"Address: 0x0001030 + (s+n) * 0x0010000 63..24 RO: Reserved 23..8 RWC: Non-fatal errors: 23..20: DMA Response Error Code (see DMA Error Address Register for DMA address triggering the error) 0=DONE 1=AERROR 3=DERROR 4=NLOCK 5=NRES 6=FLUSHED 7=FAULT 8=FAILED A=PAGED B=CONTEXT F=ILLEGAL_RSP 19: DMA Response Error Source 1=Interrupt or Restart 0=DMA Read or DMA Write 18: Received illegal command in DDCB Queue Command Register 17: Invalid Sequence number in DDCB (queue will be stopped) 16: Write attempt to DDCB Queue Start Pointer register while Queue active 15: Write attempt to DDCB Queue Configuration register while Queue active 14: Write attempt to DDCB Queue Configuration register with first DDCB index > max DDCB index 13: MMIO Cfg Write access (illegal for non cfg space area) 12: MMIO Write access to master register via slave address 11: Illegal MMIO write address 10: Illegal MMIO write alignment 9: Illegal MMIO read address 8: Illegal MMIO read alignment 7..0 RO: Reserved","title":"Not yet implemented"},{"location":"deep-dive/registers/#context-dma-error-address-register-cdear","text":"","title":"Context DMA Error Address Register (CDEAR)"},{"location":"deep-dive/registers/#not-yet-implemented-required_6","text":"Address: 0x0001038 + (s+n) * 0x0010000 63..0 RO: DMA address that caused the error","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-work-timer-cwt","text":"","title":"Context Work Timer (CWT)"},{"location":"deep-dive/registers/#not-yet-implemented-required_7","text":"Address: 0x0001080 + (s+n) * 0x0010000 63..0 RO: Counter counting the number of clock cycles during job execution for this context (Counter gets reset with every valid Job Queue Configuration Register (QCfgR) write access; the value is persistent during reset) This counter increments with the 250MHz PSL clock.","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#context-attach-status-vector-casv_1","text":"","title":"Context Attach Status Vector (CASV)"},{"location":"deep-dive/registers/#not-yet-implemented-required_8","text":"Address: 0x00C000 + (s+n) * 0x0010000 + m * 0x0000008 (m = 0,..,15) 63..32 RO: Reserved 31..0 RO: Context m*32+k is attached if (and only if) bit k is set (for each k = 0,..,31).","title":"Not yet implemented (required ???)"},{"location":"deep-dive/registers/#snap-debug-register-sdr_1","text":"Address: 0x000D000 + (s+n) * 0x0010000 63..1 RO: Reserved 0 RW: Enable PSL parity checking via AFU Control Interface to PSL '1': Parity checking is enabled '0': Parity checking is disabled (default value) POR value: 0x00000000_00000000","title":"SNAP Debug Register (SDR)"},{"location":"deep-dive/registers/#snap-nvme-register-snr_1","text":"Address: 0x000D008 + (s+n) * 0x0010000 63..0 RO: Reserved for NVMe usage POR value: 0x00000000_00000000","title":"SNAP NVMe Register (SNR)"},{"location":"deep-dive/registers/#job-manager-firs_1","text":"","title":"Job-Manager FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_10","text":"Address: 0x000E000 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: FIR bits TBD","title":"Not yet implemented"},{"location":"deep-dive/registers/#mmio-firs_1","text":"","title":"MMIO FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_11","text":"Address: 0x000E008 + (s+n) * 0x0010000 63..32 RO: Reserved 31..1 RO: Reserved (FIR bits TBD) 0 RO: Parity errror","title":"Not yet implemented"},{"location":"deep-dive/registers/#dma-firs_1","text":"","title":"DMA FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_12","text":"Address: 0x000E010 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Reserved (FIR bits TBD)","title":"Not yet implemented"},{"location":"deep-dive/registers/#attached-action-firs","text":"","title":"Attached Action FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_13","text":"Address: 0x000E018 + (s+n) * 0x0010000 63..32 RO: Reserved 31..0 RO: Reserved (FIR bits TBD)","title":"Not yet implemented"},{"location":"deep-dive/registers/#action-i-firs_1","text":"","title":"Action i FIRs"},{"location":"deep-dive/registers/#not-yet-implemented_14","text":"Address: 0x000E100 + (s+n) * 0x0010000 + i * 0x0000008 63..0 RO: TBD by Action","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-job-manager_1","text":"","title":"Error Injection Job-Manager"},{"location":"deep-dive/registers/#not-yet-implemented_15","text":"Address: 0x000E800 + (s+n) * 0x0010000 63..17 RO: Reserved 16 RO: Force Job Ctrl State Machine Hang 15..0 RO: Reserved","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-mmio_1","text":"","title":"Error Injection MMIO"},{"location":"deep-dive/registers/#not-yet-implemented_16","text":"Address: 0x000E808 + (s+n) * 0x0010000 63..17 RO: Reserved 16 RO: Inject MMIO Read Response Data Parity error into PSL interface 15..1 RO: Reserved 0 RO: Inject MMIO Write Data Parity error","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-dma_1","text":"","title":"Error Injection DMA"},{"location":"deep-dive/registers/#not-yet-implemented_17","text":"Address: 0x000E810 + (s+n) * 0x0010000 63..22 RO: Reserved 21 RO: Inject error into DMA write path (flip data bit) 20 RO: Inject error into DMA read path (flip data bit) 19 RO: Inject parity error into command on AH Command Bus to PSL 18 RO: Inject parity error into effective address on AH Command Bus to PSL 17 RO: Inject parity error into response on AH Buffer Interface to PSL 16 RO: Inject parity error into response tag on AH Command Bus to PSL 15..0 RO: Reserved","title":"Not yet implemented"},{"location":"deep-dive/registers/#error-injection-attached-action","text":"","title":"Error Injection Attached Action"},{"location":"deep-dive/registers/#not-yet-implemented_18","text":"Address: 0x000E818 + (s+n) * 0x0010000 63..0 RO: TBD by Action","title":"Not yet implemented"},{"location":"deep-dive/registers/#mmio-map-action-space","text":"Each action has a 4KB MMIO space which can be accessed from a master context or from a slave context using the address ranges as described in the respective MMIO-Map above. The following MMIO registers have dedicated meanings within the SNAP framework. When the Action gets created using Xilinx HLS the registers marked as \"Reserved\" are required for HLS control information. Otherwise, they may be used for any purpose. Offset Description Access ======= ==================== ======= 0x000 | | ... | Action control | RW 0x00C | | ==================== 0x010 | Action Type | RO ==================== 0x014 | Action Version | RO ==================== 0x018 | Reserved | 0x01C | | ==================== 0x020 | Context ID | WO ==================== 0x024 | Reserved | ==================== 0x028 | | ... Unused 0x0FC | | ==================== 0x100 | Request Queue | ... | element | WO 0x178 | | ==================== 0x17C | Reserved | ==================== 0x180 | Response Queue | ... | element | RO 0x1F8 | | ==================== 0x1FC | Reserved | ==================== 0x200 | | ... Unused 0xFFC | | ====================","title":"MMIO-Map Action Space"},{"location":"deep-dive/registers/#action-register-layout","text":"","title":"Action Register Layout"},{"location":"deep-dive/registers/#action-control-register","text":"Address: 0x000 31..8 RO: Reserved 7 RW: auto restart 6..4 RO: Reserved 3 RO: Ready 2 RO: Idle 1 RC: Done 0 RW: Start","title":"Action Control Register"},{"location":"deep-dive/registers/#interrupt-enable-register","text":"Address: 0x004 31..1 RO: Reserved 0 RW: Enable Interrupt","title":"Interrupt Enable Register"},{"location":"deep-dive/registers/#action-type-register","text":"Address: 0x010 31..0 RO: Unique four byte number specifying the type (the implemented functionality) of this action","title":"Action Type Register"},{"location":"deep-dive/registers/#action-version-register","text":"Address: 0x014 31..0 RO: Four byte number specifying the version of this action.","title":"Action Version Register"},{"location":"deep-dive/registers/#context-id-register","text":"Address: 0x020 31..8 RO: Reserved 7..0 RW: Context ID to be passed with DMA and Interrupt commands to the host.","title":"Context ID Register"},{"location":"deep-dive/registers/#psl-registers","text":"Taken from PSL spec","title":"PSL Registers"},{"location":"deep-dive/registers/#psl-slice-error-register-psl_serr_an","text":"n = 0,1,2,3 Address: BAR2 + 0x010028 + n * 0x000100 63 RWC: AFU MMIO Timeout (afuto). Enabled Accelerator did not respond to MMIO operation (mmio_afuto_err). The hang pulse frequency must be configured in PSL_DSNDCTL[mmiohp] for the hang to be detected. A read operation returns Zeroes. The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 62 RWC: MMIO targeted Accelerator that was not enabled (afudis). (mmio_dis_err) A write operation is ignored. A read operation returns data of 'DEADB00FDEADB00F' when PSL_RXCTL_An[deadb00f]=1 or all ones when PSL_RXCTL_An[deadb00f]=0.The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 61 RWC: AFU CTAG Overflow (afuov). Accelerator issued more than 64 outstanding CMD requests (rx_jm_sf_error(0)). Request is ignored and there are no ill effects to PSL. This bit is cleared by writing a '1'. 60 RWC: Bad Interrupt Source (badsrc). In AFU Directed Mode only, Accelerator issued an interrupt request with an unsupported interrupt source. The interrupt source did not fit into any enabled and defined ranges in the PSL_IVTE_LIMIT_An. The request received a 'failed' response so this notification is redundant and should be masked. In other modes this bit is reserved. This bit is cleared by writing a '1'. 59 RWC: Bad Context Handle (badctx). In AFU_Directed Mode only, the accelerator issued a request using a bad context handle. (The retrieved SWSTATE is not valid , PSL_SPAP[V]=0). The request received a context response so this notification is redundant and should be masked. In other modes this bit is reserved. 58 RWC: LLCMD to Disabled AFU (llcmddis). in AFU Directed Mode, SW updated the PSl_LLCMD_An register when the AFU was not enabled. This may not be an error and should be MASKED if expected. The LLCMD is forwarded to the translation logic which will indicate an 'error' completion status in the Software command/status field in the scheduled process area.In other modes, this bit is reserved. This bit is cleared by writing a '1'. 57 RWC: LLCMD Timeout to AFU (llcmdto). In AFU Directed Mode only, the AFU did not assert ah_jcack on the afu control interface in response to a LLCMD within the timeout period. The hang pulse frequency must be configured in PSL_RXCTL_An[afuhp] for the hang to be detected. The LLCMD is forwarded to the Translation Logic which will indicate an 'error' completion status in the Software command/status field in the scheduled process area. This notification is redundant and should be masked. In other modes, this bit is reserved. This error should be MASKED in production. This bit is clerared by writing a '1'. 56 RWC: AFU MMIO Parity Error (afupar). A MMIO read of an AFU register contained bad parity. The read operation returns data of DEADB00FDEADB00F when PSL_RXCTL_An[deadb00f]=1 or all ones when PSL_RXCTL_An[deadb00f]=0. The MMIO address is saved in PSL_AFU_DEBUG_A. This bit is cleared by writing a '1'. 55 RWC: AFU Duplicate CTAG Error (afudup). The accelerator issue a CMD with a CTAG that is already in use. The request is accepted but the PSL queues have been corrupted and requests may be lost. The PSL requires a reload and may start setting FIR1/2 bits. 64..48 RWC: Reserved for Implementation Specific Errors 47..34 RWC: Reserved for CAIA Defined Errors 33 RWC: AFU Error (AE). AFU asserted JDONE with JERROR in AFU Directed Mode. JERROR information is captured in the AFU_ERROR_An register. This error is asserted in the DSISR_An when in other modes. 32 RWC: (HC). Not GA1. PSL_CtxTime[Warn_Hypervisor] timer interval expires 31 RWC: (afuto_mask). Set by system software to disable reporting of afuto interrupt. 30 RWC: (afudis_mask). Set by system software to disable reporting of afudis interrupt. 29 RWC: (afuov_mask). Set by system software to disable reporting of afuov interrupt. 28 RWC: (badsrc_mask). Set by system software to disable reporting of badsrc interrupt. 27 RWC: (badctx_mask). Set by system software to disable reporting of badctx interrupt. 26 RWC: (llcmddis_mask). Set by system software to disable reporting of llcmddis interrupt. 25 RWC: (llcmdto_mask). Set by system software to disable reporting of llcmdto interrupt. 24 RWC: (afupar_mask). Set by system software to disable reporting of afupar interrupt. 23 RWC: (afudup_mask). Set by system software to disable reporting of afudup interrupt. 22..16 RWC: Reserved for Implementation Specific Error Masks 15..0 RWC: (errivte_slice). IVTE value used to report this interrupt","title":"PSL Slice Error Register (PSL_SErr_An)"},{"location":"deep-dive/registers/#psl-afu-debug-register-psl_afu_debug_an","text":"n = 0,1,2,3 Address: BAR2 + 0x0100C8 + n * 0x000100 63..58 RO: Reserved 57..34 RO: AFU MMIO Adr on Error (mmio_addr). This register contains the address of the 1st MMIO sent to the AFU that caused an (unmasked) afu mmio error to be reported in the PSl_SERR_An if afuto, afupar, or afudis. 33..32 RO: Reserved 31..16 RO: Context Handle on Error (handle) - Proposed (Not implemented yet) -This register contains the Context handle of the 1st error set in the PSL_SERR_An if badctx, llcmdto, llcmddis, or badsrc 15..11 RO: Reserved 10..0 RO: Interrupt Source on Error (int_src) - Proposed (Not implemented yet) - This register contains the Interrupt source of the 1st error set in the PSL_SERR_An if badsrc.","title":"PSL AFU Debug Register (PSL_AFU_DEBUG_An)"},{"location":"deep-dive/software-api/","text":"SNAP Software Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks. Environment Variables To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here. Directory Structure . |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"SNAP Software API"},{"location":"deep-dive/software-api/#snap-software","text":"Warning This is an initial version copied from SNAP1/2. Set of tools and library to drive the CAPI streaming framework hardware. The tools are intended to support bringup and debugging of the solution. Libsnap is intended to provide helper functions for own applications. Libsnap is planed to provide 3 different modes of operation: Job-queue mode: In this mode jobs can be send to the hardware which are put onto a queue. After completion the caller is notified. The framework offers the possiblity to generate a queue per AFU context, respectively per process using it. Within a process the queue can be exploited by multiple threads at the same time. The hardware job-manager is responsible to connect the job-request to a free FPGA-action. This is done dynamically in round-robin fashion. There is a request and a completion queue. The jobs can finish asyncronously depending on how long they take. FIXME Not fully in plan yet Action-assignment mode: A process requests the connection between an AFU-context to an FPGA-action. This connection is managed by the job-manager and supports as many assignments as FPGA-actions are available. Once connected the process can use FPGA-action MMIOs to do further work e.g. implement door-bells, or data-send/receive queues. Interrupts can be used for error or completion notification. Direct access cards AFU-master/slave contexts. This mode is for debugging and global configuration tasks.","title":"SNAP Software"},{"location":"deep-dive/software-api/#environment-variables","text":"To debug libsnap functionality or associated actions, there are currently some environment variables available: - SNAP_CONFIG : 0x1 Enable software action emulation for those actions which we use for trying out. Instead of 0x0 or 0x1 one can also use FPGA or CPU. - SNAP_TRACE : 0x1 General libsnap trace, 0x2 Enable register read/write trace, 0x4 Enable simulation specific trace, 0x8 Enable action traces. Applications might use more bits above those defined here.","title":"Environment Variables"},{"location":"deep-dive/software-api/#directory-structure","text":". |-- include libsnap.h and auxiliary C-headers | snap_types.h contains shared data types and definitions between the host-code | and SNAP actions |-- lib libsnap.so/.a |-- scripts Testcases `-- tools Generic tools for SNAP users. E.g.: snap_maint setup tool which needs to be called before using the card. It sets up the SNAP action assignment hardware. snap_peek/poke debug tools to read/write SNAP MMIO registers.","title":"Directory Structure"},{"location":"misc/doc-guide/","text":"How to generate this website This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository. Installation 1. Install python and pip python and pip 2. Install mkdocs-bootswatch pip install mkdocs-bootswatch Please refer to bootswatch for more information. 3. Install a markdown editor You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs . 4. Install Inkscape This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss. Website Structure First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed. Write Markdown pages On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately.. Play with pictures The first rule Reduce the usage of pictures. Avoid unnecessary screenshots. It's quite easy You can insert jpg, png, svg files. You can also just Ctrl-C and Ctrl-V pictures. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them will be created. The generated html webpage will use those relative links to show the pictures. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora. Use diagrams from PPT For the diagrams from Microsoft PowerPoint, here is a good way to have the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. You can select the region of a diagram in PPT, Ctrl-C and Ctrl-V in Typora directly. Thus it will save it as a PNG file. In my experiment, this PNG is of 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when people zoom in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different. Deploy to Github Pages When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Document Guide"},{"location":"misc/doc-guide/#how-to-generate-this-website","text":"This static documentation website is created by MkDocs and is using a theme from bootswatch . It uses \"github pages\" and this site is hosted by Github. The documentation source files are written in Markdown format. With MkDocs tool, the generated site files (html files) are automatically pushed into a specific branch gh-pages of the git repository.","title":"How to generate this website"},{"location":"misc/doc-guide/#installation","text":"","title":"Installation"},{"location":"misc/doc-guide/#1-install-python-and-pip","text":"python and pip","title":"1. Install python and pip"},{"location":"misc/doc-guide/#2-install-mkdocs-bootswatch","text":"pip install mkdocs-bootswatch Please refer to bootswatch for more information.","title":"2. Install mkdocs-bootswatch"},{"location":"misc/doc-guide/#3-install-a-markdown-editor","text":"You can simply edit the markdown (.md) files by any text editor, but it's better to user a professional markdown editor. For example, typora . It supports all of the platforms (Windows/MacOS/Linux). With a Markdown editor, you can insert pictures more easily and can watch the markdown effects when you write. Note Please configure typora to strict Markdown mode. That ensures you get the same output effects on both typora and mkdocs .","title":"3. Install a markdown editor"},{"location":"misc/doc-guide/#4-install-inkscape","text":"This step is optional. Inkscape is a free drawing tool and can help you draw and convert vector graphics. They have smaller file sizes and can be scaled without image quality loss.","title":"4. Install Inkscape"},{"location":"misc/doc-guide/#website-structure","text":"First, you need to git clone the oc-snap repository and go to web-doc directory. Make sure you are working on a branch other than master. git clone git@github.ibm.com:OC-Enablement/oc-snap.git git checkout <A branch other than master> cd oc-snap/web-doc The docs folder is where to put the markdown files, and the mkdocs.yml lists the website structure and global definitons. For example, this site has a structure like: nav: - Home: 'index.md' - User Guide: - 'Prepare Environment': 'user-guide/prepare-env.md' - 'Run an example': 'user-guide/run-example.md' - 'Create a new action': 'user-guide/new-action.md' - 'Co-Simulation': 'user-guide/co-simulation.md' - 'FPGA Image build': 'user-guide/make-image.md' - 'Optimize HLS action': 'user-guide/optimize-hls.md' - 'Deploy on Power Server': 'user-guide/deploy.md' - 'Debug an issue': 'user-guide/debug-issue.md' - 'Command Reference': 'user-guide/command-reference.md' - Examples: - 'hdl_example': 'actions-doc/hdl-example.md' - 'hdl_helloworld': 'actions-doc/hdl-helloworld.md' - 'hls_helloworld': 'actions-doc/hls-helloworld.md' - 'hls_memcopy': 'actions-doc/hls-memcopy.md' - Deep Dive: - 'SNAP Software API': 'deep-dive/libosnap.md' - 'SNAP Registers': 'deep-dive/registers.md' - 'SNAP Logic Design': 'deep-dive/snap_core.md' - 'New Board Support': 'deep-dive/board-package.md' - Misc: - 'Document Guide': 'misc/doc-guide.md' You can edit them as needed.","title":"Website Structure"},{"location":"misc/doc-guide/#write-markdown-pages","text":"On your local desktop, edit markdown files under web-doc/docs folder. If you want to add/delete/rename the files, you also need to edit mkdocs.yml Now it's time to work with an editor (i.e, typora) to write the documents. You also may need to learn some markdown syntax. Don't worry, that's easy. In your terminal (MacOS or Linux), or cmd (Windows), start a serve process: mkdocs serve Then open a web browser, input http://127.0.0.1:8000 . So whenever you save any markdown files, you can check the generated website immediately..","title":"Write Markdown pages"},{"location":"misc/doc-guide/#play-with-pictures","text":"","title":"Play with pictures"},{"location":"misc/doc-guide/#the-first-rule","text":"Reduce the usage of pictures. Avoid unnecessary screenshots.","title":"The first rule"},{"location":"misc/doc-guide/#its-quite-easy","text":"You can insert jpg, png, svg files. You can also just Ctrl-C and Ctrl-V pictures. Typora will automatically copy the files into a directory ./${filename}.assets , and here ${filename} is the name of markdown file. The inserted or copied pictures will be saved in this directory and relative links pointed to them will be created. The generated html webpage will use those relative links to show the pictures. Note Please enable \"Copy images into ./${filename}.assets folder\" in Preferences of typora.","title":"It's quite easy"},{"location":"misc/doc-guide/#use-diagrams-from-ppt","text":"For the diagrams from Microsoft PowerPoint, here is a good way to have the smallest file size and best quality: In PowerPoint, select the region of diagram, right-click mouse -> \"Save as Picture ...\" and save it as \"PDF\" format. Open the PDF file with Inkscape . (Right-click the file -> \"Open with ...\", choose Inkscape in the poped up list). Unclick \"Embed images\" and then \"OK\". In Inkscape, save it as SVG file. You can select the region of a diagram in PPT, Ctrl-C and Ctrl-V in Typora directly. Thus it will save it as a PNG file. In my experiment, this PNG is of 188KB. But with the above flow to save it as SVG file, its size is 62KB. As a vectored diagram, it doesn't have any quality loss when people zoom in. Warning Please use normal fonts in PPT, for example \"Arial\". Otherwise you may get a SVG file with a replaced font and that may look different.","title":"Use diagrams from PPT"},{"location":"misc/doc-guide/#deploy-to-github-pages","text":"When most of the edition work is done, and it's time to commit your documents to oc-snap github. First, you should commit and push your changes of source files (in web-doc ) to git repository. Create pull request, ask someone to review the documents, merge them into master branch after getting approvements. Then you can simply publish website with just one step: cd <PATH>/oc-snap/web-doc mkdocs gh-deploy The entire website will be pushed to gh-pages branch of oc-snap repository. The documentation website will be available at https://pages.github.ibm.com/oc-enablement/oc-snap !","title":"Deploy to Github Pages"},{"location":"user-guide/co-simulation/","text":"Get started This is my start. I want it.","title":"Co-Simulation"},{"location":"user-guide/co-simulation/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/command-reference/","text":"Get started This is my start. I want it.","title":"Command Reference"},{"location":"user-guide/command-reference/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/debug-issue/","text":"Get started This is my start.","title":"Debug an issue"},{"location":"user-guide/debug-issue/#get-started","text":"This is my start.","title":"Get started"},{"location":"user-guide/deploy/","text":"Get started This is my start. I want it.","title":"Deploy on Power Server"},{"location":"user-guide/deploy/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/make-image/","text":"Get started This is my start. I want it.","title":"FPGA Image build"},{"location":"user-guide/make-image/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/new-action/","text":"Get started This is my start. I want it.","title":"Create a new action"},{"location":"user-guide/new-action/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/optimize-hls/","text":"Get started This is my start. I want it.","title":"Optimize HLS action"},{"location":"user-guide/optimize-hls/#get-started","text":"This is my start. I want it.","title":"Get started"},{"location":"user-guide/prepare-env/","text":"Prepare Environment Firstly, you need to have an x86 machine for developement. Check Tools Vivado xterm Simulators gcc Clone Repositories git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update Warning Please be aware of hardware/oc-bip. If you made changes in that submodule, please do remove the \"build\" directory manually. ( hardware/oc-bip/$CARD/oc-bsp/build ) Otherwise it will not be re-built automatically from the snap build scripts. git clone ocse!!!","title":"Prepare Environment"},{"location":"user-guide/prepare-env/#prepare-environment","text":"Firstly, you need to have an x86 machine for developement.","title":"Prepare Environment"},{"location":"user-guide/prepare-env/#check-tools","text":"","title":"Check Tools"},{"location":"user-guide/prepare-env/#vivado","text":"","title":"Vivado"},{"location":"user-guide/prepare-env/#xterm","text":"","title":"xterm"},{"location":"user-guide/prepare-env/#simulators","text":"","title":"Simulators"},{"location":"user-guide/prepare-env/#gcc","text":"","title":"gcc"},{"location":"user-guide/prepare-env/#clone-repositories","text":"git clone git@github.ibm.com:OC-Enablement/oc-snap.git cd oc-snap git submodule init git submodule update Warning Please be aware of hardware/oc-bip. If you made changes in that submodule, please do remove the \"build\" directory manually. ( hardware/oc-bip/$CARD/oc-bsp/build ) Otherwise it will not be re-built automatically from the snap build scripts. git clone ocse!!!","title":"Clone Repositories"},{"location":"user-guide/run-example/","text":"Get started This is my start. I want it.","title":"Run an example"},{"location":"user-guide/run-example/#get-started","text":"This is my start. I want it.","title":"Get started"}]}